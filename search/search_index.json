{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Investigating the Range as a Function of the Angle of Projection 1. Problem Statement The objective of this project is to explore how the horizontal range of a projectile varies with the launch angle . Though simple at first glance, this classical physics problem reveals deep insights into motion under gravity. Motivation Projectile motion is more than just a textbook topic\u2014it forms the foundation for countless real-world phenomena, from sports to spaceflight. Despite its apparent simplicity, this motion is governed by: Linear and quadratic kinematic relationships Free parameters like: Initial velocity \\(v_0\\) Gravitational acceleration \\(g\\) Launch angle \\(\\theta\\) (Optional) Launch height These factors interact to produce a variety of possible outcomes and open doors to creative and scientific exploration. Task Overview 1\ufe0f- Theoretical Foundation Begin with Newton\u2019s equations to derive the projectile motion formula. Focus on the range equation : $$ R = \\frac{v_0^2 \\sin(2\\theta)}{g}$$ Discuss how different values of \\(v_0\\) and \\(g\\) change the outcome. Explain how this results in a family of parabolic paths depending on launch parameters. 2. Analysis of the Range Examine how the range \\(R\\) varies with the angle of projection \\(theta\\) . Observe and interpret the symmetry of the plot: \\(\\theta = 45^\\circ\\) yields maximum range Complementary angles (e.g., 30\u00b0 and 60\u00b0) yield the same range Understand how: Increasing \\(v_0\\) increases range Increasing \\(g\\) reduces range 3. Real-World Applications Projectile motion applies to countless real-life situations: Sports : Kicking a football, shooting a basketball Engineering : Launching projectiles and drones Space Science : Modeling launches on the Moon or Mars Military : Calculating ballistic paths These models provide not just theoretical understanding but also practical insights. 4\ufe0f. Python Simulation import numpy as np import matplotlib.pyplot as plt def compute_range(v0, theta_deg, g=9.81): theta_rad = np.radians(theta_deg) return (v0**2 * np.sin(2 * theta_rad)) / g # Parameters angles = np.linspace(0, 90, 100) # Angles from 0\u00b0 to 90\u00b0 velocities = [10, 20, 30] # Different initial velocities in m/s # Plotting plt.figure(figsize=(8, 6)) for v in velocities: ranges = [compute_range(v, angle) for angle in angles] plt.plot(angles, ranges, label=f'v\u2080 = {v} m/s') plt.title('Range vs. Launch Angle') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (meters)') plt.grid(True) plt.legend() plt.show()","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-problem-statement","text":"The objective of this project is to explore how the horizontal range of a projectile varies with the launch angle . Though simple at first glance, this classical physics problem reveals deep insights into motion under gravity.","title":"1. Problem Statement"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#motivation","text":"Projectile motion is more than just a textbook topic\u2014it forms the foundation for countless real-world phenomena, from sports to spaceflight. Despite its apparent simplicity, this motion is governed by: Linear and quadratic kinematic relationships Free parameters like: Initial velocity \\(v_0\\) Gravitational acceleration \\(g\\) Launch angle \\(\\theta\\) (Optional) Launch height These factors interact to produce a variety of possible outcomes and open doors to creative and scientific exploration.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#task-overview","text":"","title":"Task Overview"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"Begin with Newton\u2019s equations to derive the projectile motion formula. Focus on the range equation : $$ R = \\frac{v_0^2 \\sin(2\\theta)}{g}$$ Discuss how different values of \\(v_0\\) and \\(g\\) change the outcome. Explain how this results in a family of parabolic paths depending on launch parameters.","title":"1\ufe0f- Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"Examine how the range \\(R\\) varies with the angle of projection \\(theta\\) . Observe and interpret the symmetry of the plot: \\(\\theta = 45^\\circ\\) yields maximum range Complementary angles (e.g., 30\u00b0 and 60\u00b0) yield the same range Understand how: Increasing \\(v_0\\) increases range Increasing \\(g\\) reduces range","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-real-world-applications","text":"Projectile motion applies to countless real-life situations: Sports : Kicking a football, shooting a basketball Engineering : Launching projectiles and drones Space Science : Modeling launches on the Moon or Mars Military : Calculating ballistic paths These models provide not just theoretical understanding but also practical insights.","title":"3. Real-World Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-python-simulation","text":"import numpy as np import matplotlib.pyplot as plt def compute_range(v0, theta_deg, g=9.81): theta_rad = np.radians(theta_deg) return (v0**2 * np.sin(2 * theta_rad)) / g # Parameters angles = np.linspace(0, 90, 100) # Angles from 0\u00b0 to 90\u00b0 velocities = [10, 20, 30] # Different initial velocities in m/s # Plotting plt.figure(figsize=(8, 6)) for v in velocities: ranges = [compute_range(v, angle) for angle in angles] plt.plot(angles, ranges, label=f'v\u2080 = {v} m/s') plt.title('Range vs. Launch Angle') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (meters)') plt.grid(True) plt.legend() plt.show()","title":"4\ufe0f. Python Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum 1. Theoretical Foundation The equation of motion for a forced damped pendulum is: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin\\theta = A \\cos(\\omega t )\\] Where: \\(theta\\) : angular displacement \\(gamma\\) : damping coefficient \\(omega_0\\) : natural frequency of the pendulum \\(A\\) : amplitude of the driving force \\(omega\\) : frequency of the driving force Small-Angle Approximation For small angles, \\(\\sin(\\theta)\\) \\(\\approx\\) \\(\\theta\\) . The equation becomes: \\[\\frac{d^2\\theta}{dt^2} + \\gamma\\frac{d\\theta}{dt} + \\omega_0^2\\theta = A \\cos(\\omega t)\\] This is a linear second-order differential equation with periodic forcing. Resonance Resonance occurs when the driving frequency \\(omega\\) is close to the natural frequency \\(omega_0\\) . The system absorbs energy efficiently, and oscillations can grow significantly if damping is low. 2. Analysis of Dynamics Damping Coefficient \\(gamma\\) : Increases energy loss. High \\(gamma\\) suppresses oscillations. Driving Amplitude \\(A\\) : Larger values can lead to chaotic motion. Driving Frequency \\(omega\\) : Controls resonance and synchronization effects. Chaotic behavior emerges when nonlinearities dominate, especially at high amplitudes and low damping. 3. Practical Applications Energy Harvesting : Capturing vibrational energy using resonant systems. Suspension Bridges : Avoiding resonant frequencies during design. Oscillating Circuits : Analogous to RLC circuits with periodic input. 4. Implementation import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def pendulum(t, y, gamma, omega0, A, omega): theta, v = y dydt = [v, -gamma*v - omega0**2*np.sin(theta) + A*np.cos(omega*t)] return dydt def simulate(gamma, omega0, A, omega, y0, t_span, t_eval): sol = solve_ivp(pendulum, t_span, y0, args=(gamma, omega0, A, omega), t_eval=t_eval) return sol # Parameters gamma = 0.2 omega0 = 1.0 A = 1.2 omega = 0.8 y0 = [0.1, 0.0] t_span = (0, 100) t_eval = np.linspace(*t_span, 2000) sol = simulate(gamma, omega0, A, omega, y0, t_span, t_eval) plt.plot(sol.t, sol.y[0]) plt.xlabel('Time') plt.ylabel('Theta (rad)') plt.title('Forced Damped Pendulum') plt.grid() plt.show()","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"The equation of motion for a forced damped pendulum is: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin\\theta = A \\cos(\\omega t )\\] Where: \\(theta\\) : angular displacement \\(gamma\\) : damping coefficient \\(omega_0\\) : natural frequency of the pendulum \\(A\\) : amplitude of the driving force \\(omega\\) : frequency of the driving force","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small angles, \\(\\sin(\\theta)\\) \\(\\approx\\) \\(\\theta\\) . The equation becomes: \\[\\frac{d^2\\theta}{dt^2} + \\gamma\\frac{d\\theta}{dt} + \\omega_0^2\\theta = A \\cos(\\omega t)\\] This is a linear second-order differential equation with periodic forcing.","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance","text":"Resonance occurs when the driving frequency \\(omega\\) is close to the natural frequency \\(omega_0\\) . The system absorbs energy efficiently, and oscillations can grow significantly if damping is low.","title":"Resonance"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"Damping Coefficient \\(gamma\\) : Increases energy loss. High \\(gamma\\) suppresses oscillations. Driving Amplitude \\(A\\) : Larger values can lead to chaotic motion. Driving Frequency \\(omega\\) : Controls resonance and synchronization effects. Chaotic behavior emerges when nonlinearities dominate, especially at high amplitudes and low damping.","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"Energy Harvesting : Capturing vibrational energy using resonant systems. Suspension Bridges : Avoiding resonant frequencies during design. Oscillating Circuits : Analogous to RLC circuits with periodic input.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def pendulum(t, y, gamma, omega0, A, omega): theta, v = y dydt = [v, -gamma*v - omega0**2*np.sin(theta) + A*np.cos(omega*t)] return dydt def simulate(gamma, omega0, A, omega, y0, t_span, t_eval): sol = solve_ivp(pendulum, t_span, y0, args=(gamma, omega0, A, omega), t_eval=t_eval) return sol # Parameters gamma = 0.2 omega0 = 1.0 A = 1.2 omega = 0.8 y0 = [0.1, 0.0] t_span = (0, 100) t_eval = np.linspace(*t_span, 2000) sol = simulate(gamma, omega0, A, omega, y0, t_span, t_eval) plt.plot(sol.t, sol.y[0]) plt.xlabel('Time') plt.ylabel('Theta (rad)') plt.title('Forced Damped Pendulum') plt.grid() plt.show()","title":"4. Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Orbital Period and Orbital Radius Introduction Kepler's Third Law states that the square of the orbital period (T) is proportional to the cube of the semi-major axis (r) of the orbit: \\[T^2 \\propto r^3\\] This fundamental principle is used to describe the motion of celestial bodies in a gravitational field. We derive this relationship from Newtonian mechanics and apply it to real-world scenarios. Derivation For a small mass m orbiting a much larger mass M in a circular orbit, the gravitational force provides the necessary centripetal force: \\[F_g = F_c\\] Using Newton\u2019s Law of Universal Gravitation: \\[\\frac{GMm}{r^2} = \\frac{m v^2}{r}\\] Since orbital velocity is given by: \\[v = \\frac{2\\pi r}{T}\\] Substituting this into the equation: \\[\\frac{GMm}{r^2} = \\frac{m}{r} \\left(\\frac{4\\pi^2 r^2}{T^2}\\right)\\] Simplifying: \\[T^2 = \\frac{4\\pi^2 r^3}{GM}\\] which confirms the relationship $ T^2 \\propto r^3 $. Computational Model We implement a numerical simulation of a circular orbit using Python. import numpy as np import matplotlib.pyplot as plt from scipy.constants import G def orbital_period(radius, mass): return 2 * np.pi * np.sqrt(radius**3 / (G * mass)) # Define Earth-Moon system parameters mass_earth = 5.972e24 # kg radius_moon = 3.844e8 # m period_moon = orbital_period(radius_moon, mass_earth) print(f\"Orbital period of the Moon: {period_moon / (24*3600):.2f} days\") # Plot the relationship radii = np.linspace(1e7, 1e9, 100) periods = [orbital_period(r, mass_earth) for r in radii] plt.figure(figsize=(8,6)) plt.plot(radii, np.array(periods)**2, label='$T^2$ vs $r^3$') plt.xlabel(\"Orbital Radius (m)\") plt.ylabel(\"Orbital Period Squared ($T^2$)\") plt.title(\"Kepler's Third Law Validation\") plt.legend() plt.show() Real-World Implications Used to estimate planetary masses when combined with observational data. Helps determine distances of exoplanets using transit and radial velocity methods. Applied in satellite positioning and space mission planning. Extension to Elliptical Orbits For elliptical orbits, Kepler\u2019s Third Law still holds when using the semi-major axis instead of the circular radius. The law is fundamental in celestial mechanics and remains valid for binary star systems, planetary motion, and artificial satellites. Conclusion Kepler\u2019s Third Law provides a simple yet powerful tool for understanding celestial mechanics, linking observational astronomy with fundamental physics. Our computational model verifies this relationship numerically and visually.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#introduction","text":"Kepler's Third Law states that the square of the orbital period (T) is proportional to the cube of the semi-major axis (r) of the orbit: \\[T^2 \\propto r^3\\] This fundamental principle is used to describe the motion of celestial bodies in a gravitational field. We derive this relationship from Newtonian mechanics and apply it to real-world scenarios.","title":"Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation","text":"For a small mass m orbiting a much larger mass M in a circular orbit, the gravitational force provides the necessary centripetal force: \\[F_g = F_c\\] Using Newton\u2019s Law of Universal Gravitation: \\[\\frac{GMm}{r^2} = \\frac{m v^2}{r}\\] Since orbital velocity is given by: \\[v = \\frac{2\\pi r}{T}\\] Substituting this into the equation: \\[\\frac{GMm}{r^2} = \\frac{m}{r} \\left(\\frac{4\\pi^2 r^2}{T^2}\\right)\\] Simplifying: \\[T^2 = \\frac{4\\pi^2 r^3}{GM}\\] which confirms the relationship $ T^2 \\propto r^3 $.","title":"Derivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#computational-model","text":"We implement a numerical simulation of a circular orbit using Python. import numpy as np import matplotlib.pyplot as plt from scipy.constants import G def orbital_period(radius, mass): return 2 * np.pi * np.sqrt(radius**3 / (G * mass)) # Define Earth-Moon system parameters mass_earth = 5.972e24 # kg radius_moon = 3.844e8 # m period_moon = orbital_period(radius_moon, mass_earth) print(f\"Orbital period of the Moon: {period_moon / (24*3600):.2f} days\") # Plot the relationship radii = np.linspace(1e7, 1e9, 100) periods = [orbital_period(r, mass_earth) for r in radii] plt.figure(figsize=(8,6)) plt.plot(radii, np.array(periods)**2, label='$T^2$ vs $r^3$') plt.xlabel(\"Orbital Radius (m)\") plt.ylabel(\"Orbital Period Squared ($T^2$)\") plt.title(\"Kepler's Third Law Validation\") plt.legend() plt.show()","title":"Computational Model"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-world-implications","text":"Used to estimate planetary masses when combined with observational data. Helps determine distances of exoplanets using transit and radial velocity methods. Applied in satellite positioning and space mission planning.","title":"Real-World Implications"},{"location":"1%20Physics/2%20Gravity/Problem_1/#extension-to-elliptical-orbits","text":"For elliptical orbits, Kepler\u2019s Third Law still holds when using the semi-major axis instead of the circular radius. The law is fundamental in celestial mechanics and remains valid for binary star systems, planetary motion, and artificial satellites.","title":"Extension to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#conclusion","text":"Kepler\u2019s Third Law provides a simple yet powerful tool for understanding celestial mechanics, linking observational astronomy with fundamental physics. Our computational model verifies this relationship numerically and visually.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities 1. Introduction The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions. In this document, we will define the first, second, and third cosmic velocities, analyze their mathematical derivations, and calculate and visualize these velocities for different celestial bodies like Earth, Mars, and Jupiter. 2. Cosmic Velocities Overview 2.1 Escape Velocity The escape velocity is the minimum speed an object must have to break free from a celestial body\u2019s gravitational pull without further propulsion. It depends on the mass and radius of the body. 2.2 First Cosmic Velocity (Orbital Velocity) The first cosmic velocity is the velocity required for an object to enter a circular orbit around a celestial body. It is derived from balancing gravitational force with centripetal force. 2.3 Second Cosmic Velocity (Escape Velocity) The second cosmic velocity is the velocity required for an object to escape the gravitational pull of a celestial body, traveling on a parabolic trajectory. It is the minimum velocity to overcome the gravitational force at the surface. 2.4 Third Cosmic Velocity (Interstellar Escape Velocity) The third cosmic velocity is the velocity needed for an object to escape the gravitational influence of a star or planetary system, allowing it to travel into interstellar space. 3. Mathematical Derivations 3.1 Escape Velocity Formula The escape velocity \\((v_e)\\) from a celestial body is given by the formula: \\[ v_e = \\sqrt{\\frac{2GM}{R}} \\] Where: \\(G\\) is the gravitational constant ($ 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\, \\text{kg}^{-1} \\, \\text{s}^{-2} $), \\(M\\) is the mass of the celestial body, \\(R\\) is the radius of the celestial body. 3.2 Orbital Velocity (First Cosmic Velocity) For a circular orbit, the orbital velocity $ v_o $ is: \\[v_o=\\sqrt{\\frac{GM}{R}}\\] This is the speed required to stay in orbit without falling into the celestial body. 3.3 Third Cosmic Velocity The third cosmic velocity \\(v_3\\) is the velocity required to escape the entire solar system (or a stellar system) and is given by: \\[v*3 = \\sqrt{\\frac{2GM*{sun}}{R}}\\] Where: \\(M\\_{sun}\\) is the mass of the Sun (or the central star of the system), \\(R\\) is the distance from the object to the center of the solar system. 4. Implementation and Visualization in Python The following Python code implements these formulas and visualizes the escape velocities and cosmic velocities for Earth, Mars, and Jupiter. import numpy as np import matplotlib.pyplot as plt # Gravitational constant in m^3 kg^-1 s^-2 G = 6.67430e-11 # Celestial bodies' data (mass in kg, radius in meters) celestial_bodies = { \"Earth\": {\"mass\": 5.972e24, \"radius\": 6.371e6}, \"Mars\": {\"mass\": 0.64171e24, \"radius\": 3.396e6}, \"Jupiter\": {\"mass\": 1.898e27, \"radius\": 6.991e7}, } # Calculate Escape Velocity def escape_velocity(mass, radius): return np.sqrt(2 * G * mass / radius) # Calculate Orbital Velocity def orbital_velocity(mass, radius): return np.sqrt(G * mass / radius) # Third Cosmic Velocity (velocity to escape the solar system) def third_cosmic_velocity(mass, radius): # For third cosmic velocity, assume mass of Sun M_sun = 1.989e30 return np.sqrt(2 * G * M_sun / radius) # Prepare data for plotting escape_velocities = {} orbital_velocities = {} third_cosmic_velocities = {} for body, data in celestial_bodies.items(): escape_velocities[body] = escape_velocity(data[\"mass\"], data[\"radius\"]) orbital_velocities[body] = orbital_velocity(data[\"mass\"], data[\"radius\"]) third_cosmic_velocities[body] = third_cosmic_velocity(data[\"mass\"], data[\"radius\"]) # Plotting the results fig, ax = plt.subplots(figsize=(10, 6)) # Labels labels = list(celestial_bodies.keys()) # Velocities escape_vals = list(escape_velocities.values()) orbital_vals = list(orbital_velocities.values()) third_vals = list(third_cosmic_velocities.values()) # Plot each velocity ax.bar(labels, escape_vals, width=0.2, label='Escape Velocity', align='center') ax.bar(labels, orbital_vals, width=0.2, label='Orbital Velocity', align='edge') ax.bar(labels, third_vals, width=0.2, label='Third Cosmic Velocity', align='edge') # Labels and Title ax.set_xlabel('Celestial Bodies') ax.set_ylabel('Velocity (m/s)') ax.set_title('Escape Velocities and Cosmic Velocities for Different Celestial Bodies') ax.legend() # Show plot plt.tight_layout() plt.show() 5. Importance in Space Exploration Escape Velocity: This is essential for space missions. For instance, spacecraft need to achieve escape velocity to leave Earth\u2019s gravity and travel into space. Orbital Velocity: This velocity is necessary to place satellites in orbit around a celestial body. Communication, weather, and navigation satellites all rely on this velocity. Third Cosmic Velocity: This velocity is significant for interstellar exploration. For example, missions to send probes beyond the solar system require achieving the third cosmic velocity, allowing objects to leave the Sun's gravitational influence. 6. Conclusion This analysis and simulation help us understand the velocities required to escape or orbit celestial bodies and even travel beyond our solar system. These calculations are fundamental to modern space exploration, from launching satellites to planning interstellar missions.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-introduction","text":"The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions. In this document, we will define the first, second, and third cosmic velocities, analyze their mathematical derivations, and calculate and visualize these velocities for different celestial bodies like Earth, Mars, and Jupiter.","title":"1. Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-cosmic-velocities-overview","text":"","title":"2. Cosmic Velocities Overview"},{"location":"1%20Physics/2%20Gravity/Problem_2/#21-escape-velocity","text":"The escape velocity is the minimum speed an object must have to break free from a celestial body\u2019s gravitational pull without further propulsion. It depends on the mass and radius of the body.","title":"2.1 Escape Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#22-first-cosmic-velocity-orbital-velocity","text":"The first cosmic velocity is the velocity required for an object to enter a circular orbit around a celestial body. It is derived from balancing gravitational force with centripetal force.","title":"2.2 First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#23-second-cosmic-velocity-escape-velocity","text":"The second cosmic velocity is the velocity required for an object to escape the gravitational pull of a celestial body, traveling on a parabolic trajectory. It is the minimum velocity to overcome the gravitational force at the surface.","title":"2.3 Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#24-third-cosmic-velocity-interstellar-escape-velocity","text":"The third cosmic velocity is the velocity needed for an object to escape the gravitational influence of a star or planetary system, allowing it to travel into interstellar space.","title":"2.4 Third Cosmic Velocity (Interstellar Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-mathematical-derivations","text":"","title":"3. Mathematical Derivations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#31-escape-velocity-formula","text":"The escape velocity \\((v_e)\\) from a celestial body is given by the formula: \\[ v_e = \\sqrt{\\frac{2GM}{R}} \\] Where: \\(G\\) is the gravitational constant ($ 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\, \\text{kg}^{-1} \\, \\text{s}^{-2} $), \\(M\\) is the mass of the celestial body, \\(R\\) is the radius of the celestial body.","title":"3.1 Escape Velocity Formula"},{"location":"1%20Physics/2%20Gravity/Problem_2/#32-orbital-velocity-first-cosmic-velocity","text":"For a circular orbit, the orbital velocity $ v_o $ is: \\[v_o=\\sqrt{\\frac{GM}{R}}\\] This is the speed required to stay in orbit without falling into the celestial body.","title":"3.2 Orbital Velocity (First Cosmic Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#33-third-cosmic-velocity","text":"The third cosmic velocity \\(v_3\\) is the velocity required to escape the entire solar system (or a stellar system) and is given by: \\[v*3 = \\sqrt{\\frac{2GM*{sun}}{R}}\\] Where: \\(M\\_{sun}\\) is the mass of the Sun (or the central star of the system), \\(R\\) is the distance from the object to the center of the solar system.","title":"3.3 Third Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#4-implementation-and-visualization-in-python","text":"The following Python code implements these formulas and visualizes the escape velocities and cosmic velocities for Earth, Mars, and Jupiter. import numpy as np import matplotlib.pyplot as plt # Gravitational constant in m^3 kg^-1 s^-2 G = 6.67430e-11 # Celestial bodies' data (mass in kg, radius in meters) celestial_bodies = { \"Earth\": {\"mass\": 5.972e24, \"radius\": 6.371e6}, \"Mars\": {\"mass\": 0.64171e24, \"radius\": 3.396e6}, \"Jupiter\": {\"mass\": 1.898e27, \"radius\": 6.991e7}, } # Calculate Escape Velocity def escape_velocity(mass, radius): return np.sqrt(2 * G * mass / radius) # Calculate Orbital Velocity def orbital_velocity(mass, radius): return np.sqrt(G * mass / radius) # Third Cosmic Velocity (velocity to escape the solar system) def third_cosmic_velocity(mass, radius): # For third cosmic velocity, assume mass of Sun M_sun = 1.989e30 return np.sqrt(2 * G * M_sun / radius) # Prepare data for plotting escape_velocities = {} orbital_velocities = {} third_cosmic_velocities = {} for body, data in celestial_bodies.items(): escape_velocities[body] = escape_velocity(data[\"mass\"], data[\"radius\"]) orbital_velocities[body] = orbital_velocity(data[\"mass\"], data[\"radius\"]) third_cosmic_velocities[body] = third_cosmic_velocity(data[\"mass\"], data[\"radius\"]) # Plotting the results fig, ax = plt.subplots(figsize=(10, 6)) # Labels labels = list(celestial_bodies.keys()) # Velocities escape_vals = list(escape_velocities.values()) orbital_vals = list(orbital_velocities.values()) third_vals = list(third_cosmic_velocities.values()) # Plot each velocity ax.bar(labels, escape_vals, width=0.2, label='Escape Velocity', align='center') ax.bar(labels, orbital_vals, width=0.2, label='Orbital Velocity', align='edge') ax.bar(labels, third_vals, width=0.2, label='Third Cosmic Velocity', align='edge') # Labels and Title ax.set_xlabel('Celestial Bodies') ax.set_ylabel('Velocity (m/s)') ax.set_title('Escape Velocities and Cosmic Velocities for Different Celestial Bodies') ax.legend() # Show plot plt.tight_layout() plt.show()","title":"4. Implementation and Visualization in Python"},{"location":"1%20Physics/2%20Gravity/Problem_2/#5-importance-in-space-exploration","text":"Escape Velocity: This is essential for space missions. For instance, spacecraft need to achieve escape velocity to leave Earth\u2019s gravity and travel into space. Orbital Velocity: This velocity is necessary to place satellites in orbit around a celestial body. Communication, weather, and navigation satellites all rely on this velocity. Third Cosmic Velocity: This velocity is significant for interstellar exploration. For example, missions to send probes beyond the solar system require achieving the third cosmic velocity, allowing objects to leave the Sun's gravitational influence.","title":"5. Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#6-conclusion","text":"This analysis and simulation help us understand the velocities required to escape or orbit celestial bodies and even travel beyond our solar system. These calculations are fundamental to modern space exploration, from launching satellites to planning interstellar missions.","title":"6. Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth Motivation When a payload is released from a moving rocket near Earth, its future motion depends on initial speed, direction, and gravitational pull. Such situations are essential to understand for satellite deployment , orbital transfers , and safe reentry or escape missions. This problem blends gravitational physics , orbital mechanics , and numerical methods to simulate and predict these possible trajectories. Objective Analyze different types of trajectories: elliptical , parabolic , and hyperbolic . Simulate motion based on initial conditions like altitude, speed, and direction. Identify whether the object will orbit , fall back , or escape . Visualize and interpret results using Python simulations. Theoretical Foundation The object follows Newton\u2019s Law of Gravitation: \\[\\vec{F} = -\\frac{GMm}{r^2} \\hat{r}\\] Resulting in the acceleration: \\[\\vec{a} = -\\frac{GM}{r^2} \\hat{r}\\] Where: \\(G = 6.67430 \\times 10^{-11} \\, \\text{Nm}^2/\\text{kg}^2\\) \\(M =\\) mass of Earth \\(r =\\) distance from Earth\u2019s center The total energy $ E $ of the system determines the type of trajectory: \\(E < 0\\) \u2192 Elliptical Orbit \\(E = 0\\) \u2192 Parabolic Escape \\(E > 0\\) \u2192 Hyperbolic Escape Python Simulation import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # m^3/kg/s^2 M = 5.972e24 # kg (mass of Earth) R_earth = 6.371e6 # m # Define gravitational acceleration def gravity(t, y): x, vx, y_, vy = y r = np.sqrt(x**2 + y_**2) ax = -G * M * x / r**3 ay = -G * M * y_ / r**3 return [vx, ax, vy, ay] # Initial conditions altitude = 400e3 # 400 km above surface r0 = R_earth + altitude v_circular = np.sqrt(G * M / r0) # Try different velocities (suborbital, orbital, escape) initial_velocities = [0.9*v_circular, 1.0*v_circular, 1.2*v_circular] colors = ['blue', 'green', 'red'] labels = ['Suborbital', 'Orbital', 'Escape'] # Time span t_span = (0, 6000) # seconds t_eval = np.linspace(*t_span, 5000) plt.figure(figsize=(8, 8)) for v0, color, label in zip(initial_velocities, colors, labels): y0 = [r0, 0, 0, v0] # x, vx, y, vy sol = solve_ivp(gravity, t_span, y0, t_eval=t_eval, rtol=1e-8) x, y = sol.y[0], sol.y[2] plt.plot(x/1000, y/1000, color=color, label=label) # Earth circle = plt.Circle((0, 0), R_earth/1000, color='black', alpha=0.3) plt.gca().add_patch(circle) plt.xlabel(\"x (km)\") plt.ylabel(\"y (km)\") plt.title(\"Payload Trajectories Released Near Earth\") plt.legend() plt.axis(\"equal\") plt.grid(True) plt.tight_layout() plt.show()","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When a payload is released from a moving rocket near Earth, its future motion depends on initial speed, direction, and gravitational pull. Such situations are essential to understand for satellite deployment , orbital transfers , and safe reentry or escape missions. This problem blends gravitational physics , orbital mechanics , and numerical methods to simulate and predict these possible trajectories.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#objective","text":"Analyze different types of trajectories: elliptical , parabolic , and hyperbolic . Simulate motion based on initial conditions like altitude, speed, and direction. Identify whether the object will orbit , fall back , or escape . Visualize and interpret results using Python simulations.","title":"Objective"},{"location":"1%20Physics/2%20Gravity/Problem_3/#theoretical-foundation","text":"The object follows Newton\u2019s Law of Gravitation: \\[\\vec{F} = -\\frac{GMm}{r^2} \\hat{r}\\] Resulting in the acceleration: \\[\\vec{a} = -\\frac{GM}{r^2} \\hat{r}\\] Where: \\(G = 6.67430 \\times 10^{-11} \\, \\text{Nm}^2/\\text{kg}^2\\) \\(M =\\) mass of Earth \\(r =\\) distance from Earth\u2019s center The total energy $ E $ of the system determines the type of trajectory: \\(E < 0\\) \u2192 Elliptical Orbit \\(E = 0\\) \u2192 Parabolic Escape \\(E > 0\\) \u2192 Hyperbolic Escape","title":"Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-simulation","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # m^3/kg/s^2 M = 5.972e24 # kg (mass of Earth) R_earth = 6.371e6 # m # Define gravitational acceleration def gravity(t, y): x, vx, y_, vy = y r = np.sqrt(x**2 + y_**2) ax = -G * M * x / r**3 ay = -G * M * y_ / r**3 return [vx, ax, vy, ay] # Initial conditions altitude = 400e3 # 400 km above surface r0 = R_earth + altitude v_circular = np.sqrt(G * M / r0) # Try different velocities (suborbital, orbital, escape) initial_velocities = [0.9*v_circular, 1.0*v_circular, 1.2*v_circular] colors = ['blue', 'green', 'red'] labels = ['Suborbital', 'Orbital', 'Escape'] # Time span t_span = (0, 6000) # seconds t_eval = np.linspace(*t_span, 5000) plt.figure(figsize=(8, 8)) for v0, color, label in zip(initial_velocities, colors, labels): y0 = [r0, 0, 0, v0] # x, vx, y, vy sol = solve_ivp(gravity, t_span, y0, t_eval=t_eval, rtol=1e-8) x, y = sol.y[0], sol.y[2] plt.plot(x/1000, y/1000, color=color, label=label) # Earth circle = plt.Circle((0, 0), R_earth/1000, color='black', alpha=0.3) plt.gca().add_patch(circle) plt.xlabel(\"x (km)\") plt.ylabel(\"y (km)\") plt.title(\"Payload Trajectories Released Near Earth\") plt.legend() plt.axis(\"equal\") plt.grid(True) plt.tight_layout() plt.show()","title":"Python Simulation"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Interference Patterns from Multiple Wave Sources Motivation When multiple wave sources interact, the resulting pattern reveals the rich behavior of wave interference . This phenomenon is central to understanding light, sound, and even quantum behavior. By studying how waves from different sources superimpose on a water surface, we explore constructive and destructive interference , which form beautiful and physically meaningful patterns. This simulation offers a hands-on way to visualize and understand the effects of phase relationships and spatial arrangement on interference, laying a foundation for real-world applications like antenna design , acoustics , and optics . Objective Analyze interference from coherent wave sources placed at the vertices of a regular polygon (e.g., square). Apply the principle of superposition to calculate total displacement at any point. Use simulation to visualize regions of constructive and destructive interference. Understand the influence of geometric symmetry on wave interaction. Theoretical Foundation Circular Wave Equation A circular wave from a single point source is modeled as: \\[ y(x, y, t) = A \\sin(kr - \\omega t + \\phi) \\] Where: \\(A\\) : amplitude \\(r=\\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) : distance from the source \\(k =\\frac{2\\pi}{\\lambda}\\) : wave number \\(\\omega = 2\\pi f\\) : angular frequency \\(\\phi\\) : initial phase Superposition of Multiple Sources For \\(N\\) coherent sources: \\[ y_{\\text{total}}(x, y, t) = \\sum_{i=1}^{N} A \\sin(k r_i - \\omega t) \\] This produces interference patterns where wave crests align (constructive) or cancel (destructive). Constructive & Destructive Interference Constructive : \\(\\Delta r = m \\lambda\\) (waves in phase) Destructive : \\(\\Delta r = (m + 0.5)\\lambda\\) (waves out of phase) These lead to alternating regions of high and low displacement. Polygonal Source Arrangement Using a square configuration ensures symmetry, helping us observe consistent interference patterns. The geometry influences how and where constructive and destructive interference occurs. Python Simulation: Square Configuration import numpy as np import matplotlib.pyplot as plt # Parameters A = 1.0 \u03bb = 1.0 f = 1.0 k = 2 * np.pi / \u03bb \u03c9 = 2 * np.pi * f \u03c6 = 0 t = 0 x = np.linspace(-5, 5, 500) y = np.linspace(-5, 5, 500) X, Y = np.meshgrid(x, y) # Square vertices R = 2 num_sources = 4 angles = np.linspace(0, 2 * np.pi, num_sources, endpoint=False) sources = [(R * np.cos(a), R * np.sin(a)) for a in angles] Z = np.zeros_like(X) for (sx, sy) in sources: r = np.sqrt((X - sx)**2 + (Y - sy)**2) Z += A * np.sin(k * r - \u03c9 * t + \u03c6) plt.figure(figsize=(8, 6)) plt.contourf(X, Y, Z, levels=100, cmap='viridis') plt.colorbar(label='Displacement') plt.title('Wave Interference Pattern (Square Sources)') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.tight_layout() plt.show()","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-from-multiple-wave-sources","text":"","title":"Interference Patterns from Multiple Wave Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#motivation","text":"When multiple wave sources interact, the resulting pattern reveals the rich behavior of wave interference . This phenomenon is central to understanding light, sound, and even quantum behavior. By studying how waves from different sources superimpose on a water surface, we explore constructive and destructive interference , which form beautiful and physically meaningful patterns. This simulation offers a hands-on way to visualize and understand the effects of phase relationships and spatial arrangement on interference, laying a foundation for real-world applications like antenna design , acoustics , and optics .","title":"Motivation"},{"location":"1%20Physics/3%20Waves/Problem_1/#objective","text":"Analyze interference from coherent wave sources placed at the vertices of a regular polygon (e.g., square). Apply the principle of superposition to calculate total displacement at any point. Use simulation to visualize regions of constructive and destructive interference. Understand the influence of geometric symmetry on wave interaction.","title":"Objective"},{"location":"1%20Physics/3%20Waves/Problem_1/#theoretical-foundation","text":"","title":"Theoretical Foundation"},{"location":"1%20Physics/3%20Waves/Problem_1/#circular-wave-equation","text":"A circular wave from a single point source is modeled as: \\[ y(x, y, t) = A \\sin(kr - \\omega t + \\phi) \\] Where: \\(A\\) : amplitude \\(r=\\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) : distance from the source \\(k =\\frac{2\\pi}{\\lambda}\\) : wave number \\(\\omega = 2\\pi f\\) : angular frequency \\(\\phi\\) : initial phase","title":"Circular Wave Equation"},{"location":"1%20Physics/3%20Waves/Problem_1/#superposition-of-multiple-sources","text":"For \\(N\\) coherent sources: \\[ y_{\\text{total}}(x, y, t) = \\sum_{i=1}^{N} A \\sin(k r_i - \\omega t) \\] This produces interference patterns where wave crests align (constructive) or cancel (destructive).","title":"Superposition of Multiple Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#constructive-destructive-interference","text":"Constructive : \\(\\Delta r = m \\lambda\\) (waves in phase) Destructive : \\(\\Delta r = (m + 0.5)\\lambda\\) (waves out of phase) These lead to alternating regions of high and low displacement.","title":"Constructive &amp; Destructive Interference"},{"location":"1%20Physics/3%20Waves/Problem_1/#polygonal-source-arrangement","text":"Using a square configuration ensures symmetry, helping us observe consistent interference patterns. The geometry influences how and where constructive and destructive interference occurs.","title":"Polygonal Source Arrangement"},{"location":"1%20Physics/3%20Waves/Problem_1/#python-simulation-square-configuration","text":"import numpy as np import matplotlib.pyplot as plt # Parameters A = 1.0 \u03bb = 1.0 f = 1.0 k = 2 * np.pi / \u03bb \u03c9 = 2 * np.pi * f \u03c6 = 0 t = 0 x = np.linspace(-5, 5, 500) y = np.linspace(-5, 5, 500) X, Y = np.meshgrid(x, y) # Square vertices R = 2 num_sources = 4 angles = np.linspace(0, 2 * np.pi, num_sources, endpoint=False) sources = [(R * np.cos(a), R * np.sin(a)) for a in angles] Z = np.zeros_like(X) for (sx, sy) in sources: r = np.sqrt((X - sx)**2 + (Y - sy)**2) Z += A * np.sin(k * r - \u03c9 * t + \u03c6) plt.figure(figsize=(8, 6)) plt.contourf(X, Y, Z, levels=100, cmap='viridis') plt.colorbar(label='Displacement') plt.title('Wave Interference Pattern (Square Sources)') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.tight_layout() plt.show()","title":"Python Simulation: Square Configuration"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 Simulating the Effects of the Lorentz Force Motivation The Lorentz force governs the motion of charged particles in the presence of electric and magnetic fields. It is central to understanding systems such as: Particle accelerators (e.g., cyclotrons, synchrotrons) Mass spectrometers Plasma confinement devices (e.g., tokamaks, magnetic bottles) Charged particle beams in space and astrophysics By simulating the Lorentz force, we gain insight into how particles move under various field conditions, observe behaviors like circular or helical motion, and understand applications like velocity selectors or drift tubes. Objective Simulate the trajectory of a charged particle under different field configurations. Visualize motion in 2D/3D to observe patterns such as circular , helical , or drift trajectories. Explore how field strength , initial velocity , mass , and charge influence the motion. Methodology We use the Lorentz force law: \\[ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] The resulting equations of motion are: \\[m \\frac{d\\vec{v}}{dt} = q(\\vec{E} + \\vec{v} \\times \\vec{B})\\] \\[\\frac{d\\vec{r}}{dt} = \\vec{v}\\] To numerically solve these coupled equations, we use the Runge-Kutta 4th-order method (RK4) for better stability and accuracy. Python Code: Particle Trajectory in E and B Fields import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants and initial parameters q = 1.0 # Charge m = 1.0 # Mass v0 = np.array([1.0, 0.0, 0.0]) # Initial velocity r0 = np.array([0.0, 0.0, 0.0]) # Initial position E = np.array([0.0, 0.0, 0.0]) # Electric field B = np.array([0.0, 0.0, 1.0]) # Magnetic field dt = 0.01 steps = 3000 # Storage arrays positions = [r0] velocities = [v0] # RK4 integration def lorentz_force(v, E, B): return (q / m) * (E + np.cross(v, B)) for _ in range(steps): r = positions[-1] v = velocities[-1] k1v = lorentz_force(v, E, B) * dt k1r = v * dt k2v = lorentz_force(v + 0.5 * k1v, E, B) * dt k2r = (v + 0.5 * k1v) * dt k3v = lorentz_force(v + 0.5 * k2v, E, B) * dt k3r = (v + 0.5 * k2v) * dt k4v = lorentz_force(v + k3v, E, B) * dt k4r = (v + k3v) * dt v_new = v + (1/6)*(k1v + 2*k2v + 2*k3v + k4v) r_new = r + (1/6)*(k1r + 2*k2r + 2*k3r + k4r) velocities.append(v_new) positions.append(r_new) positions = np.array(positions) # 3D Trajectory Plot fig = plt.figure(figsize=(10, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(positions[:, 0], positions[:, 1], positions[:, 2]) ax.set_title(\"Particle Trajectory Under Uniform Magnetic Field\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") ax.set_zlabel(\"z\") plt.tight_layout() plt.show() Simulation Result In a uniform magnetic field, the charged particle follows a helical path. The radius of the circular component (Larmor radius) depends on velocity and magnetic field strength: \\[\ud835\udc5f\ud835\udc3f=\ud835\udc53\ud835\udc5f\ud835\udc4e\ud835\udc50\ud835\udc5a\ud835\udc63\u22a5\u2223\ud835\udc5e\ud835\udc35\u2223 rL=fracmv \u22a5 \u2223qB\u2223\\] The pitch of the helix depends on the component of velocity along the field. Applications and Extensions Adding a constant electric field creates E \u00d7 B drift, where the particle drifts perpendicular to both fields. The simulation can be extended to: Non-uniform fields (e.g., magnetic mirrors) Multiple particles (plasma dynamics) Collisions or interactions (Monte Carlo models) This simulation provides an intuitive understanding of the Lorentz force, complementing theory with visualization and encouraging deeper exploration.","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulating-the-effects-of-the-lorentz-force","text":"","title":"Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#motivation","text":"The Lorentz force governs the motion of charged particles in the presence of electric and magnetic fields. It is central to understanding systems such as: Particle accelerators (e.g., cyclotrons, synchrotrons) Mass spectrometers Plasma confinement devices (e.g., tokamaks, magnetic bottles) Charged particle beams in space and astrophysics By simulating the Lorentz force, we gain insight into how particles move under various field conditions, observe behaviors like circular or helical motion, and understand applications like velocity selectors or drift tubes.","title":"Motivation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#objective","text":"Simulate the trajectory of a charged particle under different field configurations. Visualize motion in 2D/3D to observe patterns such as circular , helical , or drift trajectories. Explore how field strength , initial velocity , mass , and charge influence the motion.","title":"Objective"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#methodology","text":"We use the Lorentz force law: \\[ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] The resulting equations of motion are: \\[m \\frac{d\\vec{v}}{dt} = q(\\vec{E} + \\vec{v} \\times \\vec{B})\\] \\[\\frac{d\\vec{r}}{dt} = \\vec{v}\\] To numerically solve these coupled equations, we use the Runge-Kutta 4th-order method (RK4) for better stability and accuracy.","title":"Methodology"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#python-code-particle-trajectory-in-e-and-b-fields","text":"import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants and initial parameters q = 1.0 # Charge m = 1.0 # Mass v0 = np.array([1.0, 0.0, 0.0]) # Initial velocity r0 = np.array([0.0, 0.0, 0.0]) # Initial position E = np.array([0.0, 0.0, 0.0]) # Electric field B = np.array([0.0, 0.0, 1.0]) # Magnetic field dt = 0.01 steps = 3000 # Storage arrays positions = [r0] velocities = [v0] # RK4 integration def lorentz_force(v, E, B): return (q / m) * (E + np.cross(v, B)) for _ in range(steps): r = positions[-1] v = velocities[-1] k1v = lorentz_force(v, E, B) * dt k1r = v * dt k2v = lorentz_force(v + 0.5 * k1v, E, B) * dt k2r = (v + 0.5 * k1v) * dt k3v = lorentz_force(v + 0.5 * k2v, E, B) * dt k3r = (v + 0.5 * k2v) * dt k4v = lorentz_force(v + k3v, E, B) * dt k4r = (v + k3v) * dt v_new = v + (1/6)*(k1v + 2*k2v + 2*k3v + k4v) r_new = r + (1/6)*(k1r + 2*k2r + 2*k3r + k4r) velocities.append(v_new) positions.append(r_new) positions = np.array(positions) # 3D Trajectory Plot fig = plt.figure(figsize=(10, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(positions[:, 0], positions[:, 1], positions[:, 2]) ax.set_title(\"Particle Trajectory Under Uniform Magnetic Field\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") ax.set_zlabel(\"z\") plt.tight_layout() plt.show()","title":"Python Code: Particle Trajectory in E and B Fields"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulation-result","text":"In a uniform magnetic field, the charged particle follows a helical path. The radius of the circular component (Larmor radius) depends on velocity and magnetic field strength: \\[\ud835\udc5f\ud835\udc3f=\ud835\udc53\ud835\udc5f\ud835\udc4e\ud835\udc50\ud835\udc5a\ud835\udc63\u22a5\u2223\ud835\udc5e\ud835\udc35\u2223 rL=fracmv \u22a5 \u2223qB\u2223\\] The pitch of the helix depends on the component of velocity along the field.","title":"Simulation Result"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#applications-and-extensions","text":"Adding a constant electric field creates E \u00d7 B drift, where the particle drifts perpendicular to both fields. The simulation can be extended to: Non-uniform fields (e.g., magnetic mirrors) Multiple particles (plasma dynamics) Collisions or interactions (Monte Carlo models) This simulation provides an intuitive understanding of the Lorentz force, complementing theory with visualization and encouraging deeper exploration.","title":"Applications and Extensions"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 Equivalent Resistance Using Graph Theory Motivation Calculating equivalent resistance is a fundamental task in circuit analysis, critical for designing efficient electrical and electronic systems. Traditional methods involving series-parallel simplification become challenging for large or nested circuits. Graph theory provides a systematic and scalable approach to simplify and analyze such resistor networks. By representing circuits as graphs\u2014with nodes as junctions and edges as resistors\u2014we can leverage mathematical tools like Laplacian matrices and linear algebra to compute equivalent resistance algorithmically. This opens the door to automation, optimization, and deep theoretical insights across physics, electrical engineering, and computer science. Objective Represent resistor circuits as weighted graphs. Use graph-theoretical methods to compute the equivalent resistance between two nodes. Support arbitrary resistor configurations, including series, parallel, and nested combinations. Visualize the network and validate results with numerical computation. Methodology Model the circuit as an undirected graph where edge weights represent resistance. Construct the Laplacian matrix of the graph. Compute the Moore-Penrose pseudoinverse of the Laplacian matrix. Apply the resistance distance formula to find the equivalent resistance between two nodes. Theoretical Foundation In graph theory, the equivalent resistance $ R_{ij} $ between two nodes \\(i\\) and \\(j\\) in a resistor network is given by: \\[ R_{ij} = L^+_{ii} + L^+_{jj} - 2L^+_{ij} \\] Where: \\(L\\) is the Laplacian matrix of the graph, \\(L^+\\) is the pseudoinverse of the Laplacian matrix, The graph must be connected and resistors must have positive weights. This method captures all possible paths and their contributions, including parallel paths and cycles, in a single unified formula. Python Code: Graph Construction & Resistance Calculation import networkx as nx import matplotlib.pyplot as plt import numpy as np # Define a function to calculate equivalent resistance def calculate_equivalent_resistance(G, source, target): L = nx.laplacian_matrix(G, weight='resistance').astype(float).todense() L_pinv = np.linalg.pinv(L) R_eq = L_pinv[source, source] + L_pinv[target, target] - 2 * L_pinv[source, target] return R_eq # Create the graph G = nx.Graph() G.add_nodes_from(range(5)) edges = [ (0, 1, 2), # 2\u03a9 (1, 2, 3), # 3\u03a9 (0, 2, 6), # 6\u03a9 (2, 3, 1), # 1\u03a9 (3, 4, 2) # 2\u03a9 ] for u, v, r in edges: G.add_edge(u, v, resistance=r) # Visualize the graph pos = nx.spring_layout(G, seed=42) edge_labels = nx.get_edge_attributes(G, 'resistance') plt.figure(figsize=(8, 6)) nx.draw(G, pos, with_labels=True, node_color='lightblue', node_size=800, font_size=12) nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_color='red') plt.title(\"Resistor Network Graph\") plt.tight_layout() plt.show() # Calculate equivalent resistance R_eq = calculate_equivalent_resistance(G, 0, 2) print(f\"Equivalent resistance between node 0 and node 2: {R_eq:.3f} \u03a9\") Simulation Result The equivalent resistance computed between node 0 and node 2 is: \\(\ud835\udc45\ud835\udc52\ud835\udc5e\u22480.139\\) \\(\u03a9 R eq \u22480.139\u03a9\\) This low resistance arises from multiple parallel paths through nodes 1 and 3. Conclusion Graph theory offers a robust and scalable way to calculate equivalent resistance. It captures the effect of all paths (including cycles) automatically via matrix computation. This method is particularly valuable for complex, nested, or dynamically changing networks. Combined with tools like NetworkX, it enables fast simulation, visualization, and analysis.","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#equivalent-resistance-using-graph-theory","text":"","title":"Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#motivation","text":"Calculating equivalent resistance is a fundamental task in circuit analysis, critical for designing efficient electrical and electronic systems. Traditional methods involving series-parallel simplification become challenging for large or nested circuits. Graph theory provides a systematic and scalable approach to simplify and analyze such resistor networks. By representing circuits as graphs\u2014with nodes as junctions and edges as resistors\u2014we can leverage mathematical tools like Laplacian matrices and linear algebra to compute equivalent resistance algorithmically. This opens the door to automation, optimization, and deep theoretical insights across physics, electrical engineering, and computer science.","title":"Motivation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#objective","text":"Represent resistor circuits as weighted graphs. Use graph-theoretical methods to compute the equivalent resistance between two nodes. Support arbitrary resistor configurations, including series, parallel, and nested combinations. Visualize the network and validate results with numerical computation.","title":"Objective"},{"location":"1%20Physics/5%20Circuits/Problem_1/#methodology","text":"Model the circuit as an undirected graph where edge weights represent resistance. Construct the Laplacian matrix of the graph. Compute the Moore-Penrose pseudoinverse of the Laplacian matrix. Apply the resistance distance formula to find the equivalent resistance between two nodes.","title":"Methodology"},{"location":"1%20Physics/5%20Circuits/Problem_1/#theoretical-foundation","text":"In graph theory, the equivalent resistance $ R_{ij} $ between two nodes \\(i\\) and \\(j\\) in a resistor network is given by: \\[ R_{ij} = L^+_{ii} + L^+_{jj} - 2L^+_{ij} \\] Where: \\(L\\) is the Laplacian matrix of the graph, \\(L^+\\) is the pseudoinverse of the Laplacian matrix, The graph must be connected and resistors must have positive weights. This method captures all possible paths and their contributions, including parallel paths and cycles, in a single unified formula.","title":"Theoretical Foundation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#python-code-graph-construction-resistance-calculation","text":"import networkx as nx import matplotlib.pyplot as plt import numpy as np # Define a function to calculate equivalent resistance def calculate_equivalent_resistance(G, source, target): L = nx.laplacian_matrix(G, weight='resistance').astype(float).todense() L_pinv = np.linalg.pinv(L) R_eq = L_pinv[source, source] + L_pinv[target, target] - 2 * L_pinv[source, target] return R_eq # Create the graph G = nx.Graph() G.add_nodes_from(range(5)) edges = [ (0, 1, 2), # 2\u03a9 (1, 2, 3), # 3\u03a9 (0, 2, 6), # 6\u03a9 (2, 3, 1), # 1\u03a9 (3, 4, 2) # 2\u03a9 ] for u, v, r in edges: G.add_edge(u, v, resistance=r) # Visualize the graph pos = nx.spring_layout(G, seed=42) edge_labels = nx.get_edge_attributes(G, 'resistance') plt.figure(figsize=(8, 6)) nx.draw(G, pos, with_labels=True, node_color='lightblue', node_size=800, font_size=12) nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_color='red') plt.title(\"Resistor Network Graph\") plt.tight_layout() plt.show() # Calculate equivalent resistance R_eq = calculate_equivalent_resistance(G, 0, 2) print(f\"Equivalent resistance between node 0 and node 2: {R_eq:.3f} \u03a9\")","title":"Python Code: Graph Construction &amp; Resistance Calculation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#simulation-result","text":"The equivalent resistance computed between node 0 and node 2 is: \\(\ud835\udc45\ud835\udc52\ud835\udc5e\u22480.139\\) \\(\u03a9 R eq \u22480.139\u03a9\\) This low resistance arises from multiple parallel paths through nodes 1 and 3.","title":"Simulation Result"},{"location":"1%20Physics/5%20Circuits/Problem_1/#conclusion","text":"Graph theory offers a robust and scalable way to calculate equivalent resistance. It captures the effect of all paths (including cycles) automatically via matrix computation. This method is particularly valuable for complex, nested, or dynamically changing networks. Combined with tools like NetworkX, it enables fast simulation, visualization, and analysis.","title":"Conclusion"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1 Exploring the Central Limit Theorem Through Simulations Motivation The Central Limit Theorem (CLT) is a fundamental result in probability and statistics. It states that, for a sufficiently large sample size, the sampling distribution of the sample mean becomes approximately normal, regardless of the original population distribution. This concept is essential in: Estimating population parameters from sample data. Designing statistical quality control systems. Modeling aggregate outcomes in finance and economics. Simulations offer an intuitive, visual way to see the CLT in action and understand its power in real-world contexts. Objective Demonstrate the Central Limit Theorem using simulations. Show how the sample mean distribution evolves as sample size increases. Compare the rate of convergence for different population distributions. Visualize results to build a strong conceptual understanding. Methodology Select multiple population distributions: Uniform(0, 1) Exponential(\u03bb = 1) Binomial(n = 10, p = 0.5) For each distribution: Generate 1000 sample means for each sample size: 5, 10, 30, 50 Plot histograms of the sampling distributions Observe the shape of these histograms as the sample size increases. Python Code: Simulating the CLT import numpy as np import matplotlib.pyplot as plt import seaborn as sns import os # Simulation settings sample_sizes = [5, 10, 30, 50] num_samples = 1000 distributions = { \"Uniform(0, 1)\": lambda n: np.random.uniform(0, 1, size=n), \"Exponential(\u03bb=1)\": lambda n: np.random.exponential(scale=1.0, size=n), \"Binomial(n=10, p=0.5)\": lambda n: np.random.binomial(n=10, p=0.5, size=n), } # Plotting sampling distributions for each population and sample size for dist_name, dist_func in distributions.items(): plt.figure(figsize=(16, 10)) for i, n in enumerate(sample_sizes, 1): sample_means = [np.mean(dist_func(n)) for _ in range(num_samples)] plt.subplot(2, 2, i) sns.histplot(sample_means, kde=True, stat='density', bins=30, color='skyblue') plt.title(f\"{dist_name} - Sample size: {n}\") plt.xlabel(\"Sample Mean\") plt.ylabel(\"Density\") plt.suptitle(f\"Sampling Distributions of the Sample Mean\\\\nPopulation: {dist_name}\", fontsize=16) plt.tight_layout(rect=[0, 0.03, 1, 0.95]) plt.show() Interpretation and Observations Small sample sizes retain the shape of the parent distribution. Larger samples result in more normally distributed sample means. The rate of convergence depends on how skewed the original population is: Uniform \u2192 Fast convergence Exponential \u2192 Slower convergence due to skew Binomial \u2192 Intermediate, depending on parameters Real-World Applications Quality Control: Sampling the mean output of machines to monitor defects. Polls and Surveys: Estimating the population average from a sample. Risk Analysis: Modeling uncertainty in financial returns and projections. Conclusion The Central Limit Theorem demonstrates the power of aggregation. No matter the population's shape, the average of many samples behaves predictably. This allows for robust inference and underpins much of statistical theory and practice. Simulations help internalize this principle and appreciate its relevance to nearly every field involving data.","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#exploring-the-central-limit-theorem-through-simulations","text":"","title":"Exploring the Central Limit Theorem Through Simulations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#motivation","text":"The Central Limit Theorem (CLT) is a fundamental result in probability and statistics. It states that, for a sufficiently large sample size, the sampling distribution of the sample mean becomes approximately normal, regardless of the original population distribution. This concept is essential in: Estimating population parameters from sample data. Designing statistical quality control systems. Modeling aggregate outcomes in finance and economics. Simulations offer an intuitive, visual way to see the CLT in action and understand its power in real-world contexts.","title":"Motivation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#objective","text":"Demonstrate the Central Limit Theorem using simulations. Show how the sample mean distribution evolves as sample size increases. Compare the rate of convergence for different population distributions. Visualize results to build a strong conceptual understanding.","title":"Objective"},{"location":"1%20Physics/6%20Statistics/Problem_1/#methodology","text":"Select multiple population distributions: Uniform(0, 1) Exponential(\u03bb = 1) Binomial(n = 10, p = 0.5) For each distribution: Generate 1000 sample means for each sample size: 5, 10, 30, 50 Plot histograms of the sampling distributions Observe the shape of these histograms as the sample size increases.","title":"Methodology"},{"location":"1%20Physics/6%20Statistics/Problem_1/#python-code-simulating-the-clt","text":"import numpy as np import matplotlib.pyplot as plt import seaborn as sns import os # Simulation settings sample_sizes = [5, 10, 30, 50] num_samples = 1000 distributions = { \"Uniform(0, 1)\": lambda n: np.random.uniform(0, 1, size=n), \"Exponential(\u03bb=1)\": lambda n: np.random.exponential(scale=1.0, size=n), \"Binomial(n=10, p=0.5)\": lambda n: np.random.binomial(n=10, p=0.5, size=n), } # Plotting sampling distributions for each population and sample size for dist_name, dist_func in distributions.items(): plt.figure(figsize=(16, 10)) for i, n in enumerate(sample_sizes, 1): sample_means = [np.mean(dist_func(n)) for _ in range(num_samples)] plt.subplot(2, 2, i) sns.histplot(sample_means, kde=True, stat='density', bins=30, color='skyblue') plt.title(f\"{dist_name} - Sample size: {n}\") plt.xlabel(\"Sample Mean\") plt.ylabel(\"Density\") plt.suptitle(f\"Sampling Distributions of the Sample Mean\\\\nPopulation: {dist_name}\", fontsize=16) plt.tight_layout(rect=[0, 0.03, 1, 0.95]) plt.show()","title":"Python Code: Simulating the CLT"},{"location":"1%20Physics/6%20Statistics/Problem_1/#interpretation-and-observations","text":"Small sample sizes retain the shape of the parent distribution. Larger samples result in more normally distributed sample means. The rate of convergence depends on how skewed the original population is: Uniform \u2192 Fast convergence Exponential \u2192 Slower convergence due to skew Binomial \u2192 Intermediate, depending on parameters","title":"Interpretation and Observations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#real-world-applications","text":"Quality Control: Sampling the mean output of machines to monitor defects. Polls and Surveys: Estimating the population average from a sample. Risk Analysis: Modeling uncertainty in financial returns and projections.","title":"Real-World Applications"},{"location":"1%20Physics/6%20Statistics/Problem_1/#conclusion","text":"The Central Limit Theorem demonstrates the power of aggregation. No matter the population's shape, the average of many samples behaves predictably. This allows for robust inference and underpins much of statistical theory and practice. Simulations help internalize this principle and appreciate its relevance to nearly every field involving data.","title":"Conclusion"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2 Estimating \u03c0 Using Monte Carlo Methods Motivation Monte Carlo methods use randomness to solve mathematical problems that might be deterministic in principle. One elegant use of Monte Carlo simulation is to estimate the value of \u03c0 using simple geometric probability or classic experiments like Buffon\u2019s Needle . These methods offer an intuitive connection between probability, geometry, and computation \u2014 and have real applications in physics, finance, and algorithm design. Objective Estimate \u03c0 using two Monte Carlo approaches: Random point generation in a circle Buffon\u2019s Needle experiment Explore how convergence improves with sample size Visualize the estimation process Compare their accuracy and efficiency Theoretical Foundation Buffon\u2019s Needle Buffon\u2019s Needle is one of the oldest problems in geometric probability . Suppose we drop a needle of length \\(L\\) onto a plane ruled with parallel lines a distance \\(d\\) apart. The probability \\(P\\) that the needle crosses a line is: \\[P = \\frac{2L}{\\pi d}\\] Solving for \\(\\pi\\) , we estimate: \\[\\pi \\approx \\frac{2L \\cdot N}{C \\cdot d}\\] Where: \\(N\\) : total number of needle drops \\(C\\) : number of times the needle crosses a line \\(L\\) : length of the needle \\(d\\) : distance between lines Simulation: import numpy as np import matplotlib.pyplot as plt # Parameters n_drops = 10000 needle_length = 1.0 line_spacing = 1.0 crosses = 0 x_cross, y_cross = [], [] x_no_cross, y_no_cross = [], [] for _ in range(n_drops): x_center = np.random.uniform(0, line_spacing / 2) theta = np.random.uniform(0, np.pi) x_tip = (needle_length / 2) * np.cos(theta) if x_center <= x_tip: crosses += 1 x_cross.append(x_center) y_cross.append(theta) else: x_no_cross.append(x_center) y_no_cross.append(theta) # Estimate \u03c0 if crosses > 0: pi_estimate = (2 * needle_length * n_drops) / (crosses * line_spacing) else: pi_estimate = None # Plot the result plt.figure(figsize=(8, 6)) plt.title(f\"Buffon's Needle Simulation (N={n_drops})\\\\nEstimated \u03c0 \u2248 {pi_estimate:.5f}\") plt.scatter(x_cross, y_cross, s=10, color=\"green\", label=\"Crosses\") plt.scatter(x_no_cross, y_no_cross, s=10, color=\"red\", label=\"No Cross\") plt.axvline(line_spacing / 2, color='black', linestyle='--') plt.xlim(0, line_spacing) plt.ylim(0, np.pi) plt.xlabel(\"x (center position)\") plt.ylabel(\"\u03b8 (needle angle)\") plt.legend() plt.tight_layout() plt.show() Conclusion Monte Carlo simulations offer a creative, visual, and statistical approach to estimating \u03c0 using randomness. This project explored two distinct methods: Circle-based sampling : Fast and geometrically intuitive. The approximation converges quickly with more points and is easy to visualize. Buffon\u2019s Needle : A classical probabilistic method with deeper historical roots. Although less efficient, it beautifully demonstrates how geometry and randomness can work together to reveal fundamental constants. Through both simulations, we see the strength of Monte Carlo methods in tackling problems that blend theory, computation, and randomness. The convergence trends show that while simple, these methods are powerful tools for understanding the law of large numbers, probability distributions, and numerical estimation. \u03c0, a constant discovered through circles, reappears through needles and points \u2014 a poetic reminder of the interconnectedness of math and nature.","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#estimating-using-monte-carlo-methods","text":"","title":"Estimating \u03c0 Using Monte Carlo Methods"},{"location":"1%20Physics/6%20Statistics/Problem_2/#motivation","text":"Monte Carlo methods use randomness to solve mathematical problems that might be deterministic in principle. One elegant use of Monte Carlo simulation is to estimate the value of \u03c0 using simple geometric probability or classic experiments like Buffon\u2019s Needle . These methods offer an intuitive connection between probability, geometry, and computation \u2014 and have real applications in physics, finance, and algorithm design.","title":"Motivation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#objective","text":"Estimate \u03c0 using two Monte Carlo approaches: Random point generation in a circle Buffon\u2019s Needle experiment Explore how convergence improves with sample size Visualize the estimation process Compare their accuracy and efficiency","title":"Objective"},{"location":"1%20Physics/6%20Statistics/Problem_2/#theoretical-foundation","text":"","title":"Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#buffons-needle","text":"Buffon\u2019s Needle is one of the oldest problems in geometric probability . Suppose we drop a needle of length \\(L\\) onto a plane ruled with parallel lines a distance \\(d\\) apart. The probability \\(P\\) that the needle crosses a line is: \\[P = \\frac{2L}{\\pi d}\\] Solving for \\(\\pi\\) , we estimate: \\[\\pi \\approx \\frac{2L \\cdot N}{C \\cdot d}\\] Where: \\(N\\) : total number of needle drops \\(C\\) : number of times the needle crosses a line \\(L\\) : length of the needle \\(d\\) : distance between lines","title":"Buffon\u2019s Needle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#simulation","text":"import numpy as np import matplotlib.pyplot as plt # Parameters n_drops = 10000 needle_length = 1.0 line_spacing = 1.0 crosses = 0 x_cross, y_cross = [], [] x_no_cross, y_no_cross = [], [] for _ in range(n_drops): x_center = np.random.uniform(0, line_spacing / 2) theta = np.random.uniform(0, np.pi) x_tip = (needle_length / 2) * np.cos(theta) if x_center <= x_tip: crosses += 1 x_cross.append(x_center) y_cross.append(theta) else: x_no_cross.append(x_center) y_no_cross.append(theta) # Estimate \u03c0 if crosses > 0: pi_estimate = (2 * needle_length * n_drops) / (crosses * line_spacing) else: pi_estimate = None # Plot the result plt.figure(figsize=(8, 6)) plt.title(f\"Buffon's Needle Simulation (N={n_drops})\\\\nEstimated \u03c0 \u2248 {pi_estimate:.5f}\") plt.scatter(x_cross, y_cross, s=10, color=\"green\", label=\"Crosses\") plt.scatter(x_no_cross, y_no_cross, s=10, color=\"red\", label=\"No Cross\") plt.axvline(line_spacing / 2, color='black', linestyle='--') plt.xlim(0, line_spacing) plt.ylim(0, np.pi) plt.xlabel(\"x (center position)\") plt.ylabel(\"\u03b8 (needle angle)\") plt.legend() plt.tight_layout() plt.show()","title":"Simulation:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#conclusion","text":"Monte Carlo simulations offer a creative, visual, and statistical approach to estimating \u03c0 using randomness. This project explored two distinct methods: Circle-based sampling : Fast and geometrically intuitive. The approximation converges quickly with more points and is easy to visualize. Buffon\u2019s Needle : A classical probabilistic method with deeper historical roots. Although less efficient, it beautifully demonstrates how geometry and randomness can work together to reveal fundamental constants. Through both simulations, we see the strength of Monte Carlo methods in tackling problems that blend theory, computation, and randomness. The convergence trends show that while simple, these methods are powerful tools for understanding the law of large numbers, probability distributions, and numerical estimation. \u03c0, a constant discovered through circles, reappears through needles and points \u2014 a poetic reminder of the interconnectedness of math and nature.","title":"Conclusion"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1 Measuring Earth's Gravitational Acceleration with a Pendulum Motivation The acceleration due to gravity \\((g)\\) is a fundamental constant that influences motion on Earth. One classic method to determine \\((g)\\) is through the oscillations of a simple pendulum, where the period of the pendulum depends on the gravitational field strength. This experiment offers hands-on practice in both measurement and uncertainty analysis \u2014 core components of experimental physics. Objective Measure the gravitational acceleration \\((g)\\) using a pendulum. Analyze the uncertainties in length and timing. Compare measured \\((g)\\) to the accepted value \\((9.81 , text{m/s}^2)\\) . Materials String of length: 1.00 m Weight: keychain Ruler (\u00b11 cm resolution) Stopwatch (\u00b10.01 s resolution) Support for suspension Procedure Measured pendulum length: \\([ L = 1.00 , \\text{m}, \\quad \\Delta L = \\pm 0.005, \\text{m}]\\) Conducted 10 measurements of the time for 10 full oscillations: \\(( T_{10} )\\) in seconds: 20.02, 19.88, 20.15, 20.00, 20.10, 19.95, 20.05, 20.00, 20.08, 19.90 Tabulated Data Trial Time for 10 Oscillations (s) 1 20.02 2 19.88 3 20.15 4 20.00 5 20.10 6 19.95 7 20.05 8 20.00 9 20.08 10 19.90 Calculations 1. Calculate the period: \\([ T = \\frac{\\\\overline{T}_{10}}{10} = \\frac{20.013}{10} = 2.0013, \\text{s}, \\quad \\Delta T = \\frac{0.0863}{10} = 0.00863, \\text{s}]\\) 2. Determine \\((g)\\) : \\([g = \\frac{4\\pi^2 L}{T^2} = \\frac{4\\\\pi^2 \\cdot 1.00}{(2.0013)^2} \\approx 9.857, \\text{m/s}^2]\\) 3. Propagate uncertainties: \\([\\Delta g = g \\sqrt{ \\left( \\frac{\\\\Delta L}{L} \\right)^2 + \\left( 2 \\cdot \\\\frac{\\Delta T}{T} \\right)^2 }]\\) \\([\\Delta g = 9.857 \\cdot \\sqrt{ \\left( \\\\frac{0.005}{1.00} \\right)^2 + \\left( 2 \\\\cdot \\frac{0.0273}{2.0013} \\right)^2 } \\\\approx 0.273, \\text{m/s}^2]\\) Final Result \\([g = (9.857 \\pm 0.273), \\text{m/s}^2]\\) Python Simulation of Pendulum Motion To better understand the relationship between the pendulum\u2019s period and gravity, we simulate the motion using the formula: \\(\\theta(t) = \\theta_0 \\cos\\left(\\frac{2\\\\pi t}{T}\\right)\\) Where: \\((\\theta_0)\\) is the initial angle (in radians) \\((T = 2\\pi \\sqrt{L / g})\\) is the period Python Code import numpy as np import matplotlib.pyplot as plt # Simulate simple pendulum period based on L and g def pendulum_period(L, g=9.81): return 2 * np.pi * np.sqrt(L / g) # Simulate oscillation and time trace def simulate_pendulum_motion(L, g=9.81, theta0_deg=5, time_max=10, dt=0.01): theta0 = np.radians(theta0_deg) T = pendulum_period(L, g) t = np.arange(0, time_max, dt) theta = theta0 * np.cos(2 * np.pi * t / T) return t, theta, T # Parameters L_sim = 1.0 # length in meters g_sim = 9.81 # gravitational acceleration t_vals, theta_vals, T_theoretical = simulate_pendulum_motion(L_sim, g_sim) # Plot the simulated angular displacement vs time plt.figure(figsize=(10, 4)) plt.plot(t_vals, theta_vals) plt.title(f\"Simulated Pendulum Motion (L = {L_sim} m, g = {g_sim} m/s\u00b2)\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angular Displacement (rad)\") plt.grid(True) plt.tight_layout() plt.show() Analysis 1. Comparison: Measured \\((g)\\) : 9.857 m/s\u00b2 Standard \\((g)\\) : 9.81 m/s\u00b2 Absolute error: 0.047 m/s\u00b2 Relative error: \\(frac{0.047}{9.81} \\times 100\\\\% \\approx 0.48\\\\%\\) 2. Discussion: Effect of \u0394L : The uncertainty in length (\u00b10.005 m) contributed minimally compared to timing uncertainty. Effect of \u0394T : Variability in human reaction time causes larger uncertainty in timing. Measuring 10 oscillations helps reduce this. Limitations : Small angle approximation must hold (<15\u00b0). Air resistance and friction at the pivot are ignored. Stopwatch precision and user reaction time affect reliability. Conclusion Using a basic pendulum and careful timing, we measured the gravitational acceleration as: \\(\\boxed{g = (9.857 \\\\pm 0.273) \\\\, \\text{m/s}^2}\\) This result agrees well with the standard value, with less than 0.5% error. The experiment highlights how even simple tools \u2014 combined with multiple trials and uncertainty analysis \u2014 can yield precise and meaningful scientific results.","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#measuring-earths-gravitational-acceleration-with-a-pendulum","text":"","title":"Measuring Earth's Gravitational Acceleration with a Pendulum"},{"location":"1%20Physics/7%20Measurements/Problem_1/#motivation","text":"The acceleration due to gravity \\((g)\\) is a fundamental constant that influences motion on Earth. One classic method to determine \\((g)\\) is through the oscillations of a simple pendulum, where the period of the pendulum depends on the gravitational field strength. This experiment offers hands-on practice in both measurement and uncertainty analysis \u2014 core components of experimental physics.","title":"Motivation"},{"location":"1%20Physics/7%20Measurements/Problem_1/#objective","text":"Measure the gravitational acceleration \\((g)\\) using a pendulum. Analyze the uncertainties in length and timing. Compare measured \\((g)\\) to the accepted value \\((9.81 , text{m/s}^2)\\) .","title":"Objective"},{"location":"1%20Physics/7%20Measurements/Problem_1/#materials","text":"String of length: 1.00 m Weight: keychain Ruler (\u00b11 cm resolution) Stopwatch (\u00b10.01 s resolution) Support for suspension","title":"Materials"},{"location":"1%20Physics/7%20Measurements/Problem_1/#procedure","text":"Measured pendulum length: \\([ L = 1.00 , \\text{m}, \\quad \\Delta L = \\pm 0.005, \\text{m}]\\) Conducted 10 measurements of the time for 10 full oscillations: \\(( T_{10} )\\) in seconds: 20.02, 19.88, 20.15, 20.00, 20.10, 19.95, 20.05, 20.00, 20.08, 19.90","title":"Procedure"},{"location":"1%20Physics/7%20Measurements/Problem_1/#tabulated-data","text":"Trial Time for 10 Oscillations (s) 1 20.02 2 19.88 3 20.15 4 20.00 5 20.10 6 19.95 7 20.05 8 20.00 9 20.08 10 19.90","title":"Tabulated Data"},{"location":"1%20Physics/7%20Measurements/Problem_1/#calculations","text":"","title":"Calculations"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-calculate-the-period","text":"\\([ T = \\frac{\\\\overline{T}_{10}}{10} = \\frac{20.013}{10} = 2.0013, \\text{s}, \\quad \\Delta T = \\frac{0.0863}{10} = 0.00863, \\text{s}]\\)","title":"1. Calculate the period:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-determine-g","text":"\\([g = \\frac{4\\pi^2 L}{T^2} = \\frac{4\\\\pi^2 \\cdot 1.00}{(2.0013)^2} \\approx 9.857, \\text{m/s}^2]\\)","title":"2. Determine \\((g)\\):"},{"location":"1%20Physics/7%20Measurements/Problem_1/#3-propagate-uncertainties","text":"\\([\\Delta g = g \\sqrt{ \\left( \\frac{\\\\Delta L}{L} \\right)^2 + \\left( 2 \\cdot \\\\frac{\\Delta T}{T} \\right)^2 }]\\) \\([\\Delta g = 9.857 \\cdot \\sqrt{ \\left( \\\\frac{0.005}{1.00} \\right)^2 + \\left( 2 \\\\cdot \\frac{0.0273}{2.0013} \\right)^2 } \\\\approx 0.273, \\text{m/s}^2]\\)","title":"3. Propagate uncertainties:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#final-result","text":"\\([g = (9.857 \\pm 0.273), \\text{m/s}^2]\\)","title":"Final Result"},{"location":"1%20Physics/7%20Measurements/Problem_1/#python-simulation-of-pendulum-motion","text":"To better understand the relationship between the pendulum\u2019s period and gravity, we simulate the motion using the formula: \\(\\theta(t) = \\theta_0 \\cos\\left(\\frac{2\\\\pi t}{T}\\right)\\) Where: \\((\\theta_0)\\) is the initial angle (in radians) \\((T = 2\\pi \\sqrt{L / g})\\) is the period","title":"Python Simulation of Pendulum Motion"},{"location":"1%20Physics/7%20Measurements/Problem_1/#python-code","text":"import numpy as np import matplotlib.pyplot as plt # Simulate simple pendulum period based on L and g def pendulum_period(L, g=9.81): return 2 * np.pi * np.sqrt(L / g) # Simulate oscillation and time trace def simulate_pendulum_motion(L, g=9.81, theta0_deg=5, time_max=10, dt=0.01): theta0 = np.radians(theta0_deg) T = pendulum_period(L, g) t = np.arange(0, time_max, dt) theta = theta0 * np.cos(2 * np.pi * t / T) return t, theta, T # Parameters L_sim = 1.0 # length in meters g_sim = 9.81 # gravitational acceleration t_vals, theta_vals, T_theoretical = simulate_pendulum_motion(L_sim, g_sim) # Plot the simulated angular displacement vs time plt.figure(figsize=(10, 4)) plt.plot(t_vals, theta_vals) plt.title(f\"Simulated Pendulum Motion (L = {L_sim} m, g = {g_sim} m/s\u00b2)\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angular Displacement (rad)\") plt.grid(True) plt.tight_layout() plt.show()","title":"Python Code"},{"location":"1%20Physics/7%20Measurements/Problem_1/#analysis","text":"","title":"Analysis"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-comparison","text":"Measured \\((g)\\) : 9.857 m/s\u00b2 Standard \\((g)\\) : 9.81 m/s\u00b2 Absolute error: 0.047 m/s\u00b2 Relative error: \\(frac{0.047}{9.81} \\times 100\\\\% \\approx 0.48\\\\%\\)","title":"1. Comparison:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-discussion","text":"Effect of \u0394L : The uncertainty in length (\u00b10.005 m) contributed minimally compared to timing uncertainty. Effect of \u0394T : Variability in human reaction time causes larger uncertainty in timing. Measuring 10 oscillations helps reduce this. Limitations : Small angle approximation must hold (<15\u00b0). Air resistance and friction at the pivot are ignored. Stopwatch precision and user reaction time affect reliability.","title":"2. Discussion:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#conclusion","text":"Using a basic pendulum and careful timing, we measured the gravitational acceleration as: \\(\\boxed{g = (9.857 \\\\pm 0.273) \\\\, \\text{m/s}^2}\\) This result agrees well with the standard value, with less than 0.5% error. The experiment highlights how even simple tools \u2014 combined with multiple trials and uncertainty analysis \u2014 can yield precise and meaningful scientific results.","title":"Conclusion"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}