{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Investigating the Range as a Function of the Angle of Projection 1. Problem Statement The objective of this project is to explore how the horizontal range of a projectile varies with the launch angle . Though simple at first glance, this classical physics problem reveals deep insights into motion under gravity. Motivation Projectile motion is more than just a textbook topic\u2014it forms the foundation for countless real-world phenomena, from sports to spaceflight. Despite its apparent simplicity, this motion is governed by: Linear and quadratic kinematic relationships Free parameters like: Initial velocity \\(v_0\\) Gravitational acceleration \\(g\\) Launch angle \\(\\theta\\) (Optional) Launch height These factors interact to produce a variety of possible outcomes and open doors to creative and scientific exploration. Task Overview 1\ufe0f- Theoretical Foundation Begin with Newton\u2019s equations to derive the projectile motion formula. Focus on the range equation : $$ R = \\frac{v_0^2 \\sin(2\\theta)}{g}$$ Discuss how different values of \\(v_0\\) and \\(g\\) change the outcome. Explain how this results in a family of parabolic paths depending on launch parameters. 2. Analysis of the Range Examine how the range \\(R\\) varies with the angle of projection \\(theta\\) . Observe and interpret the symmetry of the plot: \\(\\theta = 45^\\circ\\) yields maximum range Complementary angles (e.g., 30\u00b0 and 60\u00b0) yield the same range Understand how: Increasing \\(v_0\\) increases range Increasing \\(g\\) reduces range 3. Real-World Applications Projectile motion applies to countless real-life situations: Sports : Kicking a football, shooting a basketball Engineering : Launching projectiles and drones Space Science : Modeling launches on the Moon or Mars Military : Calculating ballistic paths These models provide not just theoretical understanding but also practical insights. 4\ufe0f. Python Simulation import numpy as np import matplotlib.pyplot as plt def compute_range(v0, theta_deg, g=9.81): theta_rad = np.radians(theta_deg) return (v0**2 * np.sin(2 * theta_rad)) / g # Parameters angles = np.linspace(0, 90, 100) # Angles from 0\u00b0 to 90\u00b0 velocities = [10, 20, 30] # Different initial velocities in m/s # Plotting plt.figure(figsize=(8, 6)) for v in velocities: ranges = [compute_range(v, angle) for angle in angles] plt.plot(angles, ranges, label=f'v\u2080 = {v} m/s') plt.title('Range vs. Launch Angle') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (meters)') plt.grid(True) plt.legend() plt.show()","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-problem-statement","text":"The objective of this project is to explore how the horizontal range of a projectile varies with the launch angle . Though simple at first glance, this classical physics problem reveals deep insights into motion under gravity.","title":"1. Problem Statement"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#motivation","text":"Projectile motion is more than just a textbook topic\u2014it forms the foundation for countless real-world phenomena, from sports to spaceflight. Despite its apparent simplicity, this motion is governed by: Linear and quadratic kinematic relationships Free parameters like: Initial velocity \\(v_0\\) Gravitational acceleration \\(g\\) Launch angle \\(\\theta\\) (Optional) Launch height These factors interact to produce a variety of possible outcomes and open doors to creative and scientific exploration.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#task-overview","text":"","title":"Task Overview"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"Begin with Newton\u2019s equations to derive the projectile motion formula. Focus on the range equation : $$ R = \\frac{v_0^2 \\sin(2\\theta)}{g}$$ Discuss how different values of \\(v_0\\) and \\(g\\) change the outcome. Explain how this results in a family of parabolic paths depending on launch parameters.","title":"1\ufe0f- Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"Examine how the range \\(R\\) varies with the angle of projection \\(theta\\) . Observe and interpret the symmetry of the plot: \\(\\theta = 45^\\circ\\) yields maximum range Complementary angles (e.g., 30\u00b0 and 60\u00b0) yield the same range Understand how: Increasing \\(v_0\\) increases range Increasing \\(g\\) reduces range","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-real-world-applications","text":"Projectile motion applies to countless real-life situations: Sports : Kicking a football, shooting a basketball Engineering : Launching projectiles and drones Space Science : Modeling launches on the Moon or Mars Military : Calculating ballistic paths These models provide not just theoretical understanding but also practical insights.","title":"3. Real-World Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-python-simulation","text":"import numpy as np import matplotlib.pyplot as plt def compute_range(v0, theta_deg, g=9.81): theta_rad = np.radians(theta_deg) return (v0**2 * np.sin(2 * theta_rad)) / g # Parameters angles = np.linspace(0, 90, 100) # Angles from 0\u00b0 to 90\u00b0 velocities = [10, 20, 30] # Different initial velocities in m/s # Plotting plt.figure(figsize=(8, 6)) for v in velocities: ranges = [compute_range(v, angle) for angle in angles] plt.plot(angles, ranges, label=f'v\u2080 = {v} m/s') plt.title('Range vs. Launch Angle') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (meters)') plt.grid(True) plt.legend() plt.show()","title":"4\ufe0f. Python Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum 1. Theoretical Foundation The equation of motion for a forced damped pendulum is: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin\\theta = A \\cos(\\omega t )\\] Where: \\(theta\\) : angular displacement \\(gamma\\) : damping coefficient \\(omega_0\\) : natural frequency of the pendulum \\(A\\) : amplitude of the driving force \\(omega\\) : frequency of the driving force Small-Angle Approximation For small angles, \\(\\sin(\\theta)\\) \\(\\approx\\) \\(\\theta\\) . The equation becomes: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] This is a linear second-order differential equation with periodic forcing. Resonance Resonance occurs when the driving frequency \\(omega\\) is close to the natural frequency \\(omega_0\\) . The system absorbs energy efficiently, and oscillations can grow significantly if damping is low. 2. Analysis of Dynamics Damping Coefficient \\(gamma\\) : Increases energy loss. High \\(gamma\\) suppresses oscillations. Driving Amplitude \\(A\\) : Larger values can lead to chaotic motion. Driving Frequency \\(omega\\) : Controls resonance and synchronization effects. Chaotic behavior emerges when nonlinearities dominate, especially at high amplitudes and low damping. 3. Practical Applications Energy Harvesting : Capturing vibrational energy using resonant systems. Suspension Bridges : Avoiding resonant frequencies during design. Oscillating Circuits : Analogous to RLC circuits with periodic input. 4. Implementation import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def pendulum(t, y, gamma, omega0, A, omega): theta, v = y dydt = [v, -gamma*v - omega0**2*np.sin(theta) + A*np.cos(omega*t)] return dydt def simulate(gamma, omega0, A, omega, y0, t_span, t_eval): sol = solve_ivp(pendulum, t_span, y0, args=(gamma, omega0, A, omega), t_eval=t_eval) return sol # Parameters gamma = 0.2 omega0 = 1.0 A = 1.2 omega = 0.8 y0 = [0.1, 0.0] t_span = (0, 100) t_eval = np.linspace(*t_span, 2000) sol = simulate(gamma, omega0, A, omega, y0, t_span, t_eval) plt.plot(sol.t, sol.y[0]) plt.xlabel('Time') plt.ylabel('Theta (rad)') plt.title('Forced Damped Pendulum') plt.grid() plt.show()","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"The equation of motion for a forced damped pendulum is: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin\\theta = A \\cos(\\omega t )\\] Where: \\(theta\\) : angular displacement \\(gamma\\) : damping coefficient \\(omega_0\\) : natural frequency of the pendulum \\(A\\) : amplitude of the driving force \\(omega\\) : frequency of the driving force","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small angles, \\(\\sin(\\theta)\\) \\(\\approx\\) \\(\\theta\\) . The equation becomes: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] This is a linear second-order differential equation with periodic forcing.","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance","text":"Resonance occurs when the driving frequency \\(omega\\) is close to the natural frequency \\(omega_0\\) . The system absorbs energy efficiently, and oscillations can grow significantly if damping is low.","title":"Resonance"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"Damping Coefficient \\(gamma\\) : Increases energy loss. High \\(gamma\\) suppresses oscillations. Driving Amplitude \\(A\\) : Larger values can lead to chaotic motion. Driving Frequency \\(omega\\) : Controls resonance and synchronization effects. Chaotic behavior emerges when nonlinearities dominate, especially at high amplitudes and low damping.","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"Energy Harvesting : Capturing vibrational energy using resonant systems. Suspension Bridges : Avoiding resonant frequencies during design. Oscillating Circuits : Analogous to RLC circuits with periodic input.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def pendulum(t, y, gamma, omega0, A, omega): theta, v = y dydt = [v, -gamma*v - omega0**2*np.sin(theta) + A*np.cos(omega*t)] return dydt def simulate(gamma, omega0, A, omega, y0, t_span, t_eval): sol = solve_ivp(pendulum, t_span, y0, args=(gamma, omega0, A, omega), t_eval=t_eval) return sol # Parameters gamma = 0.2 omega0 = 1.0 A = 1.2 omega = 0.8 y0 = [0.1, 0.0] t_span = (0, 100) t_eval = np.linspace(*t_span, 2000) sol = simulate(gamma, omega0, A, omega, y0, t_span, t_eval) plt.plot(sol.t, sol.y[0]) plt.xlabel('Time') plt.ylabel('Theta (rad)') plt.title('Forced Damped Pendulum') plt.grid() plt.show()","title":"4. Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Orbital Period and Orbital Radius Introduction Kepler's Third Law states that the square of the orbital period (T) is proportional to the cube of the semi-major axis (r) of the orbit: \\[ T^2 \\propto r^3 \\] This fundamental principle is used to describe the motion of celestial bodies in a gravitational field. We derive this relationship from Newtonian mechanics and apply it to real-world scenarios. Derivation For a small mass m orbiting a much larger mass M in a circular orbit, the gravitational force provides the necessary centripetal force: \\[ F_g = F_c \\] Using Newton\u2019s Law of Universal Gravitation: \\[\\frac{GMm}{r^2} = \\frac{m v^2}{r}\\] Since orbital velocity is given by: \\[ v = \\frac{2\\pi r}{T} \\] Substituting this into the equation: \\[\\frac{GMm}{r^2} = \\frac{m}{r} \\left(\\frac{4\\pi^2 r^2}{T^2}\\right)\\] Simplifying: \\[ T^2 = \\frac{4\\pi^2 r^3}{GM} \\] which confirms the relationship $ T^2 \\propto r^3 $. Computational Model We implement a numerical simulation of a circular orbit using Python. import numpy as np import matplotlib.pyplot as plt from scipy.constants import G def orbital_period(radius, mass): return 2 * np.pi * np.sqrt(radius**3 / (G * mass)) # Define Earth-Moon system parameters mass_earth = 5.972e24 # kg radius_moon = 3.844e8 # m period_moon = orbital_period(radius_moon, mass_earth) print(f\"Orbital period of the Moon: {period_moon / (24*3600):.2f} days\") # Plot the relationship radii = np.linspace(1e7, 1e9, 100) periods = [orbital_period(r, mass_earth) for r in radii] plt.figure(figsize=(8,6)) plt.plot(radii, np.array(periods)**2, label='$T^2$ vs $r^3$') plt.xlabel(\"Orbital Radius (m)\") plt.ylabel(\"Orbital Period Squared ($T^2$)\") plt.title(\"Kepler's Third Law Validation\") plt.legend() plt.show() Real-World Implications Used to estimate planetary masses when combined with observational data. Helps determine distances of exoplanets using transit and radial velocity methods. Applied in satellite positioning and space mission planning. Extension to Elliptical Orbits For elliptical orbits, Kepler\u2019s Third Law still holds when using the semi-major axis instead of the circular radius. The law is fundamental in celestial mechanics and remains valid for binary star systems, planetary motion, and artificial satellites. Conclusion Kepler\u2019s Third Law provides a simple yet powerful tool for understanding celestial mechanics, linking observational astronomy with fundamental physics. Our computational model verifies this relationship numerically and visually.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#introduction","text":"Kepler's Third Law states that the square of the orbital period (T) is proportional to the cube of the semi-major axis (r) of the orbit: \\[ T^2 \\propto r^3 \\] This fundamental principle is used to describe the motion of celestial bodies in a gravitational field. We derive this relationship from Newtonian mechanics and apply it to real-world scenarios.","title":"Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation","text":"For a small mass m orbiting a much larger mass M in a circular orbit, the gravitational force provides the necessary centripetal force: \\[ F_g = F_c \\] Using Newton\u2019s Law of Universal Gravitation: \\[\\frac{GMm}{r^2} = \\frac{m v^2}{r}\\] Since orbital velocity is given by: \\[ v = \\frac{2\\pi r}{T} \\] Substituting this into the equation: \\[\\frac{GMm}{r^2} = \\frac{m}{r} \\left(\\frac{4\\pi^2 r^2}{T^2}\\right)\\] Simplifying: \\[ T^2 = \\frac{4\\pi^2 r^3}{GM} \\] which confirms the relationship $ T^2 \\propto r^3 $.","title":"Derivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#computational-model","text":"We implement a numerical simulation of a circular orbit using Python. import numpy as np import matplotlib.pyplot as plt from scipy.constants import G def orbital_period(radius, mass): return 2 * np.pi * np.sqrt(radius**3 / (G * mass)) # Define Earth-Moon system parameters mass_earth = 5.972e24 # kg radius_moon = 3.844e8 # m period_moon = orbital_period(radius_moon, mass_earth) print(f\"Orbital period of the Moon: {period_moon / (24*3600):.2f} days\") # Plot the relationship radii = np.linspace(1e7, 1e9, 100) periods = [orbital_period(r, mass_earth) for r in radii] plt.figure(figsize=(8,6)) plt.plot(radii, np.array(periods)**2, label='$T^2$ vs $r^3$') plt.xlabel(\"Orbital Radius (m)\") plt.ylabel(\"Orbital Period Squared ($T^2$)\") plt.title(\"Kepler's Third Law Validation\") plt.legend() plt.show()","title":"Computational Model"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-world-implications","text":"Used to estimate planetary masses when combined with observational data. Helps determine distances of exoplanets using transit and radial velocity methods. Applied in satellite positioning and space mission planning.","title":"Real-World Implications"},{"location":"1%20Physics/2%20Gravity/Problem_1/#extension-to-elliptical-orbits","text":"For elliptical orbits, Kepler\u2019s Third Law still holds when using the semi-major axis instead of the circular radius. The law is fundamental in celestial mechanics and remains valid for binary star systems, planetary motion, and artificial satellites.","title":"Extension to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#conclusion","text":"Kepler\u2019s Third Law provides a simple yet powerful tool for understanding celestial mechanics, linking observational astronomy with fundamental physics. Our computational model verifies this relationship numerically and visually.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities 1. Introduction The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions. In this document, we will define the first, second, and third cosmic velocities, analyze their mathematical derivations, and calculate and visualize these velocities for different celestial bodies like Earth, Mars, and Jupiter. 2. Cosmic Velocities Overview 2.1 Escape Velocity The escape velocity is the minimum speed an object must have to break free from a celestial body\u2019s gravitational pull without further propulsion. It depends on the mass and radius of the body. 2.2 First Cosmic Velocity (Orbital Velocity) The first cosmic velocity is the velocity required for an object to enter a circular orbit around a celestial body. It is derived from balancing gravitational force with centripetal force. 2.3 Second Cosmic Velocity (Escape Velocity) The second cosmic velocity is the velocity required for an object to escape the gravitational pull of a celestial body, traveling on a parabolic trajectory. It is the minimum velocity to overcome the gravitational force at the surface. 2.4 Third Cosmic Velocity (Interstellar Escape Velocity) The third cosmic velocity is the velocity needed for an object to escape the gravitational influence of a star or planetary system, allowing it to travel into interstellar space. 3. Mathematical Derivations 3.1 Escape Velocity Formula The escape velocity \\(( v_e)\\) from a celestial body is given by the formula: \\[ v_e = \\sqrt{\\frac{2GM}{R}} \\] Where: $ G $ is the gravitational constant ($ 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\, \\text{kg}^{-1} \\, \\text{s}^{-2} $), $ M $ is the mass of the celestial body, $ R $ is the radius of the celestial body. 3.2 Orbital Velocity (First Cosmic Velocity) For a circular orbit, the orbital velocity $ v_o $ is: \\[ v_o = \\sqrt{\\frac{GM}{R}} \\] This is the speed required to stay in orbit without falling into the celestial body. 3.3 Third Cosmic Velocity The third cosmic velocity \\(v_3\\) is the velocity required to escape the entire solar system (or a stellar system) and is given by: \\[ v*3 = \\sqrt{\\frac{2GM*{sun}}{R}} \\] Where: $ M_{sun}$ is the mass of the Sun (or the central star of the system), $ R $ is the distance from the object to the center of the solar system. 4. Implementation and Visualization in Python The following Python code implements these formulas and visualizes the escape velocities and cosmic velocities for Earth, Mars, and Jupiter. import numpy as np import matplotlib.pyplot as plt # Gravitational constant in m^3 kg^-1 s^-2 G = 6.67430e-11 # Celestial bodies' data (mass in kg, radius in meters) celestial_bodies = { \"Earth\": {\"mass\": 5.972e24, \"radius\": 6.371e6}, \"Mars\": {\"mass\": 0.64171e24, \"radius\": 3.396e6}, \"Jupiter\": {\"mass\": 1.898e27, \"radius\": 6.991e7}, } # Calculate Escape Velocity def escape_velocity(mass, radius): return np.sqrt(2 * G * mass / radius) # Calculate Orbital Velocity def orbital_velocity(mass, radius): return np.sqrt(G * mass / radius) # Third Cosmic Velocity (velocity to escape the solar system) def third_cosmic_velocity(mass, radius): # For third cosmic velocity, assume mass of Sun M_sun = 1.989e30 return np.sqrt(2 * G * M_sun / radius) # Prepare data for plotting escape_velocities = {} orbital_velocities = {} third_cosmic_velocities = {} for body, data in celestial_bodies.items(): escape_velocities[body] = escape_velocity(data[\"mass\"], data[\"radius\"]) orbital_velocities[body] = orbital_velocity(data[\"mass\"], data[\"radius\"]) third_cosmic_velocities[body] = third_cosmic_velocity(data[\"mass\"], data[\"radius\"]) # Plotting the results fig, ax = plt.subplots(figsize=(10, 6)) # Labels labels = list(celestial_bodies.keys()) # Velocities escape_vals = list(escape_velocities.values()) orbital_vals = list(orbital_velocities.values()) third_vals = list(third_cosmic_velocities.values()) # Plot each velocity ax.bar(labels, escape_vals, width=0.2, label='Escape Velocity', align='center') ax.bar(labels, orbital_vals, width=0.2, label='Orbital Velocity', align='edge') ax.bar(labels, third_vals, width=0.2, label='Third Cosmic Velocity', align='edge') # Labels and Title ax.set_xlabel('Celestial Bodies') ax.set_ylabel('Velocity (m/s)') ax.set_title('Escape Velocities and Cosmic Velocities for Different Celestial Bodies') ax.legend() # Show plot plt.tight_layout() plt.show() 5. Importance in Space Exploration Escape Velocity: This is essential for space missions. For instance, spacecraft need to achieve escape velocity to leave Earth\u2019s gravity and travel into space. Orbital Velocity: This velocity is necessary to place satellites in orbit around a celestial body. Communication, weather, and navigation satellites all rely on this velocity. Third Cosmic Velocity: This velocity is significant for interstellar exploration. For example, missions to send probes beyond the solar system require achieving the third cosmic velocity, allowing objects to leave the Sun's gravitational influence. 6. Conclusion This analysis and simulation help us understand the velocities required to escape or orbit celestial bodies and even travel beyond our solar system. These calculations are fundamental to modern space exploration, from launching satellites to planning interstellar missions.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-introduction","text":"The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions. In this document, we will define the first, second, and third cosmic velocities, analyze their mathematical derivations, and calculate and visualize these velocities for different celestial bodies like Earth, Mars, and Jupiter.","title":"1. Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-cosmic-velocities-overview","text":"","title":"2. Cosmic Velocities Overview"},{"location":"1%20Physics/2%20Gravity/Problem_2/#21-escape-velocity","text":"The escape velocity is the minimum speed an object must have to break free from a celestial body\u2019s gravitational pull without further propulsion. It depends on the mass and radius of the body.","title":"2.1 Escape Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#22-first-cosmic-velocity-orbital-velocity","text":"The first cosmic velocity is the velocity required for an object to enter a circular orbit around a celestial body. It is derived from balancing gravitational force with centripetal force.","title":"2.2 First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#23-second-cosmic-velocity-escape-velocity","text":"The second cosmic velocity is the velocity required for an object to escape the gravitational pull of a celestial body, traveling on a parabolic trajectory. It is the minimum velocity to overcome the gravitational force at the surface.","title":"2.3 Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#24-third-cosmic-velocity-interstellar-escape-velocity","text":"The third cosmic velocity is the velocity needed for an object to escape the gravitational influence of a star or planetary system, allowing it to travel into interstellar space.","title":"2.4 Third Cosmic Velocity (Interstellar Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-mathematical-derivations","text":"","title":"3. Mathematical Derivations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#31-escape-velocity-formula","text":"The escape velocity \\(( v_e)\\) from a celestial body is given by the formula: \\[ v_e = \\sqrt{\\frac{2GM}{R}} \\] Where: $ G $ is the gravitational constant ($ 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\, \\text{kg}^{-1} \\, \\text{s}^{-2} $), $ M $ is the mass of the celestial body, $ R $ is the radius of the celestial body.","title":"3.1 Escape Velocity Formula"},{"location":"1%20Physics/2%20Gravity/Problem_2/#32-orbital-velocity-first-cosmic-velocity","text":"For a circular orbit, the orbital velocity $ v_o $ is: \\[ v_o = \\sqrt{\\frac{GM}{R}} \\] This is the speed required to stay in orbit without falling into the celestial body.","title":"3.2 Orbital Velocity (First Cosmic Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#33-third-cosmic-velocity","text":"The third cosmic velocity \\(v_3\\) is the velocity required to escape the entire solar system (or a stellar system) and is given by: \\[ v*3 = \\sqrt{\\frac{2GM*{sun}}{R}} \\] Where: $ M_{sun}$ is the mass of the Sun (or the central star of the system), $ R $ is the distance from the object to the center of the solar system.","title":"3.3 Third Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#4-implementation-and-visualization-in-python","text":"The following Python code implements these formulas and visualizes the escape velocities and cosmic velocities for Earth, Mars, and Jupiter. import numpy as np import matplotlib.pyplot as plt # Gravitational constant in m^3 kg^-1 s^-2 G = 6.67430e-11 # Celestial bodies' data (mass in kg, radius in meters) celestial_bodies = { \"Earth\": {\"mass\": 5.972e24, \"radius\": 6.371e6}, \"Mars\": {\"mass\": 0.64171e24, \"radius\": 3.396e6}, \"Jupiter\": {\"mass\": 1.898e27, \"radius\": 6.991e7}, } # Calculate Escape Velocity def escape_velocity(mass, radius): return np.sqrt(2 * G * mass / radius) # Calculate Orbital Velocity def orbital_velocity(mass, radius): return np.sqrt(G * mass / radius) # Third Cosmic Velocity (velocity to escape the solar system) def third_cosmic_velocity(mass, radius): # For third cosmic velocity, assume mass of Sun M_sun = 1.989e30 return np.sqrt(2 * G * M_sun / radius) # Prepare data for plotting escape_velocities = {} orbital_velocities = {} third_cosmic_velocities = {} for body, data in celestial_bodies.items(): escape_velocities[body] = escape_velocity(data[\"mass\"], data[\"radius\"]) orbital_velocities[body] = orbital_velocity(data[\"mass\"], data[\"radius\"]) third_cosmic_velocities[body] = third_cosmic_velocity(data[\"mass\"], data[\"radius\"]) # Plotting the results fig, ax = plt.subplots(figsize=(10, 6)) # Labels labels = list(celestial_bodies.keys()) # Velocities escape_vals = list(escape_velocities.values()) orbital_vals = list(orbital_velocities.values()) third_vals = list(third_cosmic_velocities.values()) # Plot each velocity ax.bar(labels, escape_vals, width=0.2, label='Escape Velocity', align='center') ax.bar(labels, orbital_vals, width=0.2, label='Orbital Velocity', align='edge') ax.bar(labels, third_vals, width=0.2, label='Third Cosmic Velocity', align='edge') # Labels and Title ax.set_xlabel('Celestial Bodies') ax.set_ylabel('Velocity (m/s)') ax.set_title('Escape Velocities and Cosmic Velocities for Different Celestial Bodies') ax.legend() # Show plot plt.tight_layout() plt.show()","title":"4. Implementation and Visualization in Python"},{"location":"1%20Physics/2%20Gravity/Problem_2/#5-importance-in-space-exploration","text":"Escape Velocity: This is essential for space missions. For instance, spacecraft need to achieve escape velocity to leave Earth\u2019s gravity and travel into space. Orbital Velocity: This velocity is necessary to place satellites in orbit around a celestial body. Communication, weather, and navigation satellites all rely on this velocity. Third Cosmic Velocity: This velocity is significant for interstellar exploration. For example, missions to send probes beyond the solar system require achieving the third cosmic velocity, allowing objects to leave the Sun's gravitational influence.","title":"5. Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#6-conclusion","text":"This analysis and simulation help us understand the velocities required to escape or orbit celestial bodies and even travel beyond our solar system. These calculations are fundamental to modern space exploration, from launching satellites to planning interstellar missions.","title":"6. Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth Motivation When a payload is released from a moving rocket near Earth, its future motion depends on initial speed, direction, and gravitational pull. Such situations are essential to understand for satellite deployment , orbital transfers , and safe reentry or escape missions. This problem blends gravitational physics , orbital mechanics , and numerical methods to simulate and predict these possible trajectories. Objective Analyze different types of trajectories: elliptical , parabolic , and hyperbolic . Simulate motion based on initial conditions like altitude, speed, and direction. Identify whether the object will orbit , fall back , or escape . Visualize and interpret results using Python simulations. Theoretical Foundation The object follows Newton\u2019s Law of Gravitation: \\[\\vec{F} = -\\frac{GMm}{r^2} \\hat{r}\\] Resulting in the acceleration: \\[\\vec{a} = -\\frac{GM}{r^2} \\hat{r}\\] Where: $ G = 6.67430 \\times 10^{-11} \\, \\text{Nm}^2/\\text{kg}^2$ $ M = $ mass of Earth $ r = $ distance from Earth\u2019s center The total energy $ E $ of the system determines the type of trajectory: $ E < 0 $ \u2192 Elliptical Orbit $ E = 0 $ \u2192 Parabolic Escape $ E > 0 $ \u2192 Hyperbolic Escape Python Simulation import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # m^3/kg/s^2 M = 5.972e24 # kg (mass of Earth) R_earth = 6.371e6 # m # Define gravitational acceleration def gravity(t, y): x, vx, y_, vy = y r = np.sqrt(x**2 + y_**2) ax = -G * M * x / r**3 ay = -G * M * y_ / r**3 return [vx, ax, vy, ay] # Initial conditions altitude = 400e3 # 400 km above surface r0 = R_earth + altitude v_circular = np.sqrt(G * M / r0) # Try different velocities (suborbital, orbital, escape) initial_velocities = [0.9*v_circular, 1.0*v_circular, 1.2*v_circular] colors = ['blue', 'green', 'red'] labels = ['Suborbital', 'Orbital', 'Escape'] # Time span t_span = (0, 6000) # seconds t_eval = np.linspace(*t_span, 5000) plt.figure(figsize=(8, 8)) for v0, color, label in zip(initial_velocities, colors, labels): y0 = [r0, 0, 0, v0] # x, vx, y, vy sol = solve_ivp(gravity, t_span, y0, t_eval=t_eval, rtol=1e-8) x, y = sol.y[0], sol.y[2] plt.plot(x/1000, y/1000, color=color, label=label) # Earth circle = plt.Circle((0, 0), R_earth/1000, color='black', alpha=0.3) plt.gca().add_patch(circle) plt.xlabel(\"x (km)\") plt.ylabel(\"y (km)\") plt.title(\"Payload Trajectories Released Near Earth\") plt.legend() plt.axis(\"equal\") plt.grid(True) plt.tight_layout() plt.show()","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When a payload is released from a moving rocket near Earth, its future motion depends on initial speed, direction, and gravitational pull. Such situations are essential to understand for satellite deployment , orbital transfers , and safe reentry or escape missions. This problem blends gravitational physics , orbital mechanics , and numerical methods to simulate and predict these possible trajectories.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#objective","text":"Analyze different types of trajectories: elliptical , parabolic , and hyperbolic . Simulate motion based on initial conditions like altitude, speed, and direction. Identify whether the object will orbit , fall back , or escape . Visualize and interpret results using Python simulations.","title":"Objective"},{"location":"1%20Physics/2%20Gravity/Problem_3/#theoretical-foundation","text":"The object follows Newton\u2019s Law of Gravitation: \\[\\vec{F} = -\\frac{GMm}{r^2} \\hat{r}\\] Resulting in the acceleration: \\[\\vec{a} = -\\frac{GM}{r^2} \\hat{r}\\] Where: $ G = 6.67430 \\times 10^{-11} \\, \\text{Nm}^2/\\text{kg}^2$ $ M = $ mass of Earth $ r = $ distance from Earth\u2019s center The total energy $ E $ of the system determines the type of trajectory: $ E < 0 $ \u2192 Elliptical Orbit $ E = 0 $ \u2192 Parabolic Escape $ E > 0 $ \u2192 Hyperbolic Escape","title":"Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-simulation","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # m^3/kg/s^2 M = 5.972e24 # kg (mass of Earth) R_earth = 6.371e6 # m # Define gravitational acceleration def gravity(t, y): x, vx, y_, vy = y r = np.sqrt(x**2 + y_**2) ax = -G * M * x / r**3 ay = -G * M * y_ / r**3 return [vx, ax, vy, ay] # Initial conditions altitude = 400e3 # 400 km above surface r0 = R_earth + altitude v_circular = np.sqrt(G * M / r0) # Try different velocities (suborbital, orbital, escape) initial_velocities = [0.9*v_circular, 1.0*v_circular, 1.2*v_circular] colors = ['blue', 'green', 'red'] labels = ['Suborbital', 'Orbital', 'Escape'] # Time span t_span = (0, 6000) # seconds t_eval = np.linspace(*t_span, 5000) plt.figure(figsize=(8, 8)) for v0, color, label in zip(initial_velocities, colors, labels): y0 = [r0, 0, 0, v0] # x, vx, y, vy sol = solve_ivp(gravity, t_span, y0, t_eval=t_eval, rtol=1e-8) x, y = sol.y[0], sol.y[2] plt.plot(x/1000, y/1000, color=color, label=label) # Earth circle = plt.Circle((0, 0), R_earth/1000, color='black', alpha=0.3) plt.gca().add_patch(circle) plt.xlabel(\"x (km)\") plt.ylabel(\"y (km)\") plt.title(\"Payload Trajectories Released Near Earth\") plt.legend() plt.axis(\"equal\") plt.grid(True) plt.tight_layout() plt.show()","title":"Python Simulation"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}