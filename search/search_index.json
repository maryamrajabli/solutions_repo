{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1: Investigating the Range as a Function of the Angle of Projection 1. Problem Statement The aim of this project is to deeply explore how the horizontal range of a projectile depends on the launch angle \\(\\theta\\) , assuming no air resistance. Although the range equation looks simple, its implications and derivation offer valuable understanding of 2D motion under gravity. 2. Motivation & Importance Projectile motion appears frequently in engineering, sports, military applications , and planetary science . From designing robotic arms to simulating cannon trajectories or space launches\u2014mastering this topic equips learners with key analytical tools. 3. Theoretical Foundation 3.1. Assumptions To simplify our analysis, we assume: The projectile is launched from ground level. No air resistance. Constant gravitational acceleration ( \\(g \\approx 9.81\\) m/s\u00b2). 3.2. Key Equations Horizontal and Vertical Components: If the initial velocity is \\(v_0\\) and the launch angle is \\(\\theta\\) , the velocity components are: \\[ v_{0x} = v_0 \\cos(\\theta), \\quad v_{0y} = v_0 \\sin(\\theta) \\] Time of Flight (T): The projectile returns to the same vertical level when \\(y(t) = 0\\) . Using vertical motion: \\[ y(t) = v_{0y} t - \\frac{1}{2} g t^2 = 0 \\Rightarrow t = 0 \\quad \\text{or} \\quad t = \\frac{2v_0 \\sin(\\theta)}{g} \\] We take the non-zero solution: \\[ T = \\frac{2v_0 \\sin(\\theta)}{g} \\] Range (R): The horizontal distance traveled during this time is: \\[ R = v_{0x} \\cdot T = v_0 \\cos(\\theta) \\cdot \\frac{2v_0 \\sin(\\theta)}{g} \\] \\[ \\boxed{R = \\frac{v_0^2 \\sin(2\\theta)}{g}} \\] \ud83d\udca1 Insight : This equation shows that the range depends on the square of the initial speed and the sine of twice the launch angle. 3.3. Implications of the Range Formula Maximum range occurs when \\(\\sin(2\\theta)\\) is maximized \u21d2 \\(2\\theta = 90^\\circ\\) \u21d2 \\(\\theta = 45^\\circ\\) . \\(\\sin(2\\theta)\\) is symmetric about \\(45^\\circ\\) , so angles like \\(30^\\circ\\) and \\(60^\\circ\\) produce equal ranges . Larger \\(v_0\\) leads to a longer range. Higher \\(g\\) (e.g., on Jupiter) reduces the range. 4. Graphical Analysis Let\u2019s use Python to plot \\(R\\) vs. \\(\\theta\\) for different \\(v_0\\) values. import numpy as np import matplotlib.pyplot as plt def compute_range(v0, theta_deg, g=9.81): theta_rad = np.radians(theta_deg) return (v0**2 * np.sin(2 * theta_rad)) / g angles = np.linspace(0, 90, 100) velocities = [10, 20, 30] plt.figure(figsize=(9, 6)) for v in velocities: ranges = [compute_range(v, angle) for angle in angles] plt.plot(angles, ranges, label=f'v\u2080 = {v} m/s') plt.title('Projectile Range vs. Launch Angle') plt.xlabel('Launch Angle \u03b8 (degrees)') plt.ylabel('Range R (meters)') plt.grid(True) plt.legend() plt.tight_layout() plt.show() 5. Real-World Applications Sports: Calculating the optimal angle for a football throw. Engineering: Determining nozzle angles for sprinkler systems. Military: Artillery targeting under various launch conditions. Space: Simulating projectile motion on Mars, where \\(g \\approx 3.71\\) m/s\u00b2.","title":"Problem 1:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-problem-statement","text":"The aim of this project is to deeply explore how the horizontal range of a projectile depends on the launch angle \\(\\theta\\) , assuming no air resistance. Although the range equation looks simple, its implications and derivation offer valuable understanding of 2D motion under gravity.","title":"1. Problem Statement"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-motivation-importance","text":"Projectile motion appears frequently in engineering, sports, military applications , and planetary science . From designing robotic arms to simulating cannon trajectories or space launches\u2014mastering this topic equips learners with key analytical tools.","title":"2. Motivation &amp; Importance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-theoretical-foundation","text":"","title":"3. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#31-assumptions","text":"To simplify our analysis, we assume: The projectile is launched from ground level. No air resistance. Constant gravitational acceleration ( \\(g \\approx 9.81\\) m/s\u00b2).","title":"3.1. Assumptions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#32-key-equations","text":"","title":"3.2. Key Equations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-and-vertical-components","text":"If the initial velocity is \\(v_0\\) and the launch angle is \\(\\theta\\) , the velocity components are: \\[ v_{0x} = v_0 \\cos(\\theta), \\quad v_{0y} = v_0 \\sin(\\theta) \\]","title":"Horizontal and Vertical Components:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#time-of-flight-t","text":"The projectile returns to the same vertical level when \\(y(t) = 0\\) . Using vertical motion: \\[ y(t) = v_{0y} t - \\frac{1}{2} g t^2 = 0 \\Rightarrow t = 0 \\quad \\text{or} \\quad t = \\frac{2v_0 \\sin(\\theta)}{g} \\] We take the non-zero solution: \\[ T = \\frac{2v_0 \\sin(\\theta)}{g} \\]","title":"Time of Flight (T):"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-r","text":"The horizontal distance traveled during this time is: \\[ R = v_{0x} \\cdot T = v_0 \\cos(\\theta) \\cdot \\frac{2v_0 \\sin(\\theta)}{g} \\] \\[ \\boxed{R = \\frac{v_0^2 \\sin(2\\theta)}{g}} \\] \ud83d\udca1 Insight : This equation shows that the range depends on the square of the initial speed and the sine of twice the launch angle.","title":"Range (R):"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#33-implications-of-the-range-formula","text":"Maximum range occurs when \\(\\sin(2\\theta)\\) is maximized \u21d2 \\(2\\theta = 90^\\circ\\) \u21d2 \\(\\theta = 45^\\circ\\) . \\(\\sin(2\\theta)\\) is symmetric about \\(45^\\circ\\) , so angles like \\(30^\\circ\\) and \\(60^\\circ\\) produce equal ranges . Larger \\(v_0\\) leads to a longer range. Higher \\(g\\) (e.g., on Jupiter) reduces the range.","title":"3.3. Implications of the Range Formula"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-graphical-analysis","text":"Let\u2019s use Python to plot \\(R\\) vs. \\(\\theta\\) for different \\(v_0\\) values. import numpy as np import matplotlib.pyplot as plt def compute_range(v0, theta_deg, g=9.81): theta_rad = np.radians(theta_deg) return (v0**2 * np.sin(2 * theta_rad)) / g angles = np.linspace(0, 90, 100) velocities = [10, 20, 30] plt.figure(figsize=(9, 6)) for v in velocities: ranges = [compute_range(v, angle) for angle in angles] plt.plot(angles, ranges, label=f'v\u2080 = {v} m/s') plt.title('Projectile Range vs. Launch Angle') plt.xlabel('Launch Angle \u03b8 (degrees)') plt.ylabel('Range R (meters)') plt.grid(True) plt.legend() plt.tight_layout() plt.show()","title":"4. Graphical Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-real-world-applications","text":"Sports: Calculating the optimal angle for a football throw. Engineering: Determining nozzle angles for sprinkler systems. Military: Artillery targeting under various launch conditions. Space: Simulating projectile motion on Mars, where \\(g \\approx 3.71\\) m/s\u00b2.","title":"5. Real-World Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2: Investigating the Dynamics of a Forced Damped Pendulum \ud83d\udd0d Motivation The forced damped pendulum is a captivating example of a nonlinear dynamical system that showcases a wide spectrum of behaviors, from predictable oscillations to unpredictable chaos. The richness of this system arises from the interplay between damping , restoring forces , and external periodic forcing . By modifying parameters such as damping coefficient ( \\(\\\\gamma\\) ) , driving amplitude ( \\(A\\) ) , and driving frequency ( \\(\\\\omega\\) ) , one can observe: Regular harmonic motion Resonance amplification Quasiperiodic and chaotic dynamics These phenomena are foundational to understanding complex systems in nature and engineering. Real-world analogs include: Climate systems influenced by periodic solar cycles Vibration control in buildings and bridges Resonance phenomena in circuits and mechanical components 1. Theoretical Foundation The governing equation for a forced damped pendulum is: \\[ \\\\frac{d^2\\\\theta}{dt^2} + \\\\gamma \\\\frac{d\\\\theta}{dt} + \\\\omega_0^2 \\\\sin\\\\theta = A \\\\cos(\\\\omega t) \\] Where: \\(\\\\theta\\) : angular displacement \\(\\\\gamma\\) : damping coefficient \\(\\\\omega_0\\) : natural frequency \\(A\\) : amplitude of the driving force \\(\\\\omega\\) : frequency of the driving force \ud83d\udd38 Small-Angle Approximation For small oscillations ( \\(\\\\theta \\\\ll 1\\) ), we linearize the system: \\[ \\\\frac{d^2\\\\theta}{dt^2} + \\\\gamma \\\\frac{d\\\\theta}{dt} + \\\\omega_0^2\\\\theta = A \\\\cos(\\\\omega t) \\] This becomes a classic driven harmonic oscillator, where resonance can occur when \\(\\\\omega \\\\approx \\\\omega_0\\) . 2. Analysis of Dynamics Key dynamic insights include: Effect of \\(\\\\gamma\\) (damping): Higher values reduce amplitude and suppress chaotic behavior. Effect of \\(A\\) (amplitude): Higher amplitudes can cause bifurcations and chaotic transitions. Effect of \\(\\\\omega\\) (driving frequency): Controls resonance and frequency locking. Chaos and Bifurcation Nonlinearity ( \\(\\sin\\theta\\) ) introduces complex behavior: Phase diagrams show how trajectories evolve. Poincar\u00e9 sections reveal periodic, quasiperiodic, or chaotic attractors. Lyapunov exponents (optional extension) can measure sensitivity to initial conditions. 3. Practical Applications Energy Harvesting : Tuning systems to capture maximum vibrational energy. Mechanical Engineering : Avoiding catastrophic resonance in buildings and bridges. Electronics : Understanding RLC circuits and analog oscillators. 4. Implementation in Python import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def pendulum(t, y, gamma, omega0, A, omega): theta, v = y dydt = [v, -gamma*v - omega0**2*np.sin(theta) + A*np.cos(omega*t)] return dydt def simulate(gamma, omega0, A, omega, y0, t_span, t_eval): sol = solve_ivp(pendulum, t_span, y0, args=(gamma, omega0, A, omega), t_eval=t_eval) return sol # Parameters gamma = 0.2 omega0 = 1.0 A = 1.2 omega = 0.8 y0 = [0.1, 0.0] t_span = (0, 100) t_eval = np.linspace(*t_span, 2000) sol = simulate(gamma, omega0, A, omega, y0, t_span, t_eval) plt.plot(sol.t, sol.y[0]) plt.xlabel('Time') plt.ylabel('Theta (rad)') plt.title('Forced Damped Pendulum') plt.grid() plt.show()","title":"Problem 2:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum is a captivating example of a nonlinear dynamical system that showcases a wide spectrum of behaviors, from predictable oscillations to unpredictable chaos. The richness of this system arises from the interplay between damping , restoring forces , and external periodic forcing . By modifying parameters such as damping coefficient ( \\(\\\\gamma\\) ) , driving amplitude ( \\(A\\) ) , and driving frequency ( \\(\\\\omega\\) ) , one can observe: Regular harmonic motion Resonance amplification Quasiperiodic and chaotic dynamics These phenomena are foundational to understanding complex systems in nature and engineering. Real-world analogs include: Climate systems influenced by periodic solar cycles Vibration control in buildings and bridges Resonance phenomena in circuits and mechanical components","title":"\ud83d\udd0d Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"The governing equation for a forced damped pendulum is: \\[ \\\\frac{d^2\\\\theta}{dt^2} + \\\\gamma \\\\frac{d\\\\theta}{dt} + \\\\omega_0^2 \\\\sin\\\\theta = A \\\\cos(\\\\omega t) \\] Where: \\(\\\\theta\\) : angular displacement \\(\\\\gamma\\) : damping coefficient \\(\\\\omega_0\\) : natural frequency \\(A\\) : amplitude of the driving force \\(\\\\omega\\) : frequency of the driving force","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small oscillations ( \\(\\\\theta \\\\ll 1\\) ), we linearize the system: \\[ \\\\frac{d^2\\\\theta}{dt^2} + \\\\gamma \\\\frac{d\\\\theta}{dt} + \\\\omega_0^2\\\\theta = A \\\\cos(\\\\omega t) \\] This becomes a classic driven harmonic oscillator, where resonance can occur when \\(\\\\omega \\\\approx \\\\omega_0\\) .","title":"\ud83d\udd38 Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"Key dynamic insights include: Effect of \\(\\\\gamma\\) (damping): Higher values reduce amplitude and suppress chaotic behavior. Effect of \\(A\\) (amplitude): Higher amplitudes can cause bifurcations and chaotic transitions. Effect of \\(\\\\omega\\) (driving frequency): Controls resonance and frequency locking.","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#chaos-and-bifurcation","text":"Nonlinearity ( \\(\\sin\\theta\\) ) introduces complex behavior: Phase diagrams show how trajectories evolve. Poincar\u00e9 sections reveal periodic, quasiperiodic, or chaotic attractors. Lyapunov exponents (optional extension) can measure sensitivity to initial conditions.","title":"Chaos and Bifurcation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"Energy Harvesting : Tuning systems to capture maximum vibrational energy. Mechanical Engineering : Avoiding catastrophic resonance in buildings and bridges. Electronics : Understanding RLC circuits and analog oscillators.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation-in-python","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def pendulum(t, y, gamma, omega0, A, omega): theta, v = y dydt = [v, -gamma*v - omega0**2*np.sin(theta) + A*np.cos(omega*t)] return dydt def simulate(gamma, omega0, A, omega, y0, t_span, t_eval): sol = solve_ivp(pendulum, t_span, y0, args=(gamma, omega0, A, omega), t_eval=t_eval) return sol # Parameters gamma = 0.2 omega0 = 1.0 A = 1.2 omega = 0.8 y0 = [0.1, 0.0] t_span = (0, 100) t_eval = np.linspace(*t_span, 2000) sol = simulate(gamma, omega0, A, omega, y0, t_span, t_eval) plt.plot(sol.t, sol.y[0]) plt.xlabel('Time') plt.ylabel('Theta (rad)') plt.title('Forced Damped Pendulum') plt.grid() plt.show()","title":"4. Implementation in Python"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Orbital Period and Orbital Radius \u2013 Solution and Concept Objective To explore the relationship between the orbital radius and the orbital period of a satellite orbiting Earth using Newtonian Gravity and Kepler\u2019s Third Law . Theoretical Background 1. Gravitational Force Provides the Centripetal Force A satellite remains in orbit because gravity supplies the exact force needed to keep it moving in a circular path: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] \\( G \\) : Gravitational constant \\( M \\) : Mass of Earth \\( m \\) : Mass of satellite \\( r \\) : Distance from Earth\u2019s center (orbital radius) \\( v \\) : Orbital speed 2. Orbital Velocity Solving for velocity: \\[ v = \\sqrt{\\frac{G M}{r}} \\] This is the speed needed for a stable circular orbit. 3. Orbital Period The time for one full revolution is: \\[ T = \\frac{2\\pi r}{v} = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\] This shows that the orbital period depends on the cube of the radius . Kepler\u2019s Third Law of Planetary Motion \u201cThe square of the orbital period is proportional to the cube of the orbital radius.\u201d \\[T^2 \\propto r^3\\] Why it matters: This law was first observed by Johannes Kepler and later explained by Newton\u2019s theory of gravity . It is a cornerstone of celestial mechanics . It connects gravity to motion and applies to all objects in orbit \u2014 satellites, moons, and even planets around the Sun. Applications: Predicting the position of satellites and planets Designing GPS, communication, and weather satellite systems Understanding dynamics in planetary systems and galaxies \ud83d\udca1 Kepler\u2019s law provides a bridge between observational astronomy and gravitational physics \u2014 turning ancient star patterns into a predictive science. Implementation and Visualization in Python: import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) M_earth = 5.972e24 # mass of Earth (kg) # Define a function to calculate orbital period (seconds) given radius (meters) def orbital_period(r, G=G, M=M_earth): return 2 * np.pi * np.sqrt(r**3 / (G * M)) # Generate an array of orbital radii (7000 km to 50000 km) radii_km = np.linspace(7000, 50000, 500) radii_m = radii_km * 1e3 # Convert to meters # Calculate orbital periods and convert from seconds to hours periods_sec = orbital_period(radii_m) periods_hr = periods_sec / 3600 # Plot the relationship plt.figure(figsize=(10, 6)) plt.plot(radii_km, periods_hr, color='purple', linewidth=2) plt.title('Orbital Period vs Orbital Radius (around Earth)', fontsize=14) plt.xlabel('Orbital Radius (km)', fontsize=12) plt.ylabel('Orbital Period (hours)', fontsize=12) plt.grid(True, linestyle='--', alpha=0.6) plt.tight_layout() Graph: Orbital Period vs Orbital Radius X-axis : Orbital radius in kilometers (from 7000 km to 50000 km) Y-axis : Orbital period in hours Observations: The graph rises steeply : doubling the orbital radius causes more than double the period. For low Earth orbit (~7000 km) , the period is about 1.5 hours . For geostationary orbit (~42,000 km) , the period is about 24 hours . Summary The orbital period grows non-linearly with radius. This relationship reflects Kepler\u2019s Third Law : $$ \\T^2 \\propto r^3\\ Farther orbits take longer to complete. Newton\u2019s gravity gives the mechanism , and Kepler gives the relationship . Real-World Relevance \ud83d\udef0\ufe0f Satellite network design (e.g., Starlink, GPS) \ud83c\udf0c Planetary system modeling \ud83d\ude80 Space exploration route planning \ud83d\udce1 Geostationary vs. polar orbits Conclusion By analyzing this relationship, we connect gravity\u2019s fundamental principles with real-world technologies and cosmic dynamics. Kepler\u2019s Law is not just a historical observation \u2014 it\u2019s a practical tool for understanding and shaping the universe.","title":"Orbital Period and Orbital Radius \u2013 Solution and Concept"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius-solution-and-concept","text":"","title":"Orbital Period and Orbital Radius \u2013 Solution and Concept"},{"location":"1%20Physics/2%20Gravity/Problem_1/#objective","text":"To explore the relationship between the orbital radius and the orbital period of a satellite orbiting Earth using Newtonian Gravity and Kepler\u2019s Third Law .","title":"Objective"},{"location":"1%20Physics/2%20Gravity/Problem_1/#theoretical-background","text":"","title":"Theoretical Background"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-gravitational-force-provides-the-centripetal-force","text":"A satellite remains in orbit because gravity supplies the exact force needed to keep it moving in a circular path: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] \\( G \\) : Gravitational constant \\( M \\) : Mass of Earth \\( m \\) : Mass of satellite \\( r \\) : Distance from Earth\u2019s center (orbital radius) \\( v \\) : Orbital speed","title":"1. Gravitational Force Provides the Centripetal Force"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-orbital-velocity","text":"Solving for velocity: \\[ v = \\sqrt{\\frac{G M}{r}} \\] This is the speed needed for a stable circular orbit.","title":"2. Orbital Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-orbital-period","text":"The time for one full revolution is: \\[ T = \\frac{2\\pi r}{v} = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\] This shows that the orbital period depends on the cube of the radius .","title":"3. Orbital Period"},{"location":"1%20Physics/2%20Gravity/Problem_1/#keplers-third-law-of-planetary-motion","text":"\u201cThe square of the orbital period is proportional to the cube of the orbital radius.\u201d \\[T^2 \\propto r^3\\]","title":"Kepler\u2019s Third Law of Planetary Motion"},{"location":"1%20Physics/2%20Gravity/Problem_1/#why-it-matters","text":"This law was first observed by Johannes Kepler and later explained by Newton\u2019s theory of gravity . It is a cornerstone of celestial mechanics . It connects gravity to motion and applies to all objects in orbit \u2014 satellites, moons, and even planets around the Sun.","title":"Why it matters:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#applications","text":"Predicting the position of satellites and planets Designing GPS, communication, and weather satellite systems Understanding dynamics in planetary systems and galaxies \ud83d\udca1 Kepler\u2019s law provides a bridge between observational astronomy and gravitational physics \u2014 turning ancient star patterns into a predictive science.","title":"Applications:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#implementation-and-visualization-in-python","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) M_earth = 5.972e24 # mass of Earth (kg) # Define a function to calculate orbital period (seconds) given radius (meters) def orbital_period(r, G=G, M=M_earth): return 2 * np.pi * np.sqrt(r**3 / (G * M)) # Generate an array of orbital radii (7000 km to 50000 km) radii_km = np.linspace(7000, 50000, 500) radii_m = radii_km * 1e3 # Convert to meters # Calculate orbital periods and convert from seconds to hours periods_sec = orbital_period(radii_m) periods_hr = periods_sec / 3600 # Plot the relationship plt.figure(figsize=(10, 6)) plt.plot(radii_km, periods_hr, color='purple', linewidth=2) plt.title('Orbital Period vs Orbital Radius (around Earth)', fontsize=14) plt.xlabel('Orbital Radius (km)', fontsize=12) plt.ylabel('Orbital Period (hours)', fontsize=12) plt.grid(True, linestyle='--', alpha=0.6) plt.tight_layout()","title":"Implementation and Visualization in Python:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#graph-orbital-period-vs-orbital-radius","text":"X-axis : Orbital radius in kilometers (from 7000 km to 50000 km) Y-axis : Orbital period in hours","title":"Graph: Orbital Period vs Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#observations","text":"The graph rises steeply : doubling the orbital radius causes more than double the period. For low Earth orbit (~7000 km) , the period is about 1.5 hours . For geostationary orbit (~42,000 km) , the period is about 24 hours .","title":"Observations:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#summary","text":"The orbital period grows non-linearly with radius. This relationship reflects Kepler\u2019s Third Law : $$ \\T^2 \\propto r^3\\ Farther orbits take longer to complete. Newton\u2019s gravity gives the mechanism , and Kepler gives the relationship .","title":"Summary"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-world-relevance","text":"\ud83d\udef0\ufe0f Satellite network design (e.g., Starlink, GPS) \ud83c\udf0c Planetary system modeling \ud83d\ude80 Space exploration route planning \ud83d\udce1 Geostationary vs. polar orbits","title":"Real-World Relevance"},{"location":"1%20Physics/2%20Gravity/Problem_1/#conclusion","text":"By analyzing this relationship, we connect gravity\u2019s fundamental principles with real-world technologies and cosmic dynamics. Kepler\u2019s Law is not just a historical observation \u2014 it\u2019s a practical tool for understanding and shaping the universe.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities 1. Introduction The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions. In this document, we will define the first, second, and third cosmic velocities, analyze their mathematical derivations, and calculate and visualize these velocities for different celestial bodies like Earth, Mars, and Jupiter. 2. Cosmic Velocities Overview 2.1 Escape Velocity The escape velocity is the minimum speed an object must have to break free from a celestial body\u2019s gravitational pull without further propulsion. It depends on the mass and radius of the body. 2.2 First Cosmic Velocity (Orbital Velocity) The first cosmic velocity is the velocity required for an object to enter a circular orbit around a celestial body. It is derived from balancing gravitational force with centripetal force. 2.3 Second Cosmic Velocity (Escape Velocity) The second cosmic velocity is the velocity required for an object to escape the gravitational pull of a celestial body, traveling on a parabolic trajectory. It is the minimum velocity to overcome the gravitational force at the surface. 2.4 Third Cosmic Velocity (Interstellar Escape Velocity) The third cosmic velocity is the velocity needed for an object to escape the gravitational influence of a star or planetary system, allowing it to travel into interstellar space. 3. Mathematical Derivations 3.1 Escape Velocity Formula The escape velocity \\(v_e\\) from a celestial body is given by the formula: \\[v_e = \\sqrt{\\frac{2GM}{R}}\\] Where: \\(G\\) is the gravitational constant ($ 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\, \\text{kg}^{-1} \\, \\text{s}^{-2} $), \\(M\\) is the mass of the celestial body, \\(R\\) is the radius of the celestial body. 3.2 Orbital Velocity (First Cosmic Velocity) For a circular orbit, the orbital velocity \\(v_o\\) is: \\[v_o=\\sqrt{\\frac{GM}{R}}\\] This is the speed required to stay in orbit without falling into the celestial body. 3.3 Third Cosmic Velocity The third cosmic velocity \\(v_3\\) is the velocity required to escape the entire solar system (or a stellar system) and is given by: \\[v*3 = \\sqrt{\\frac{2GM*{sun}}{R}}\\] Where: \\(M\\_{sun}\\) is the mass of the Sun (or the central star of the system), \\(R\\) is the distance from the object to the center of the solar system. 4. Implementation and Visualization in Python The following Python code implements these formulas and visualizes the escape velocities and cosmic velocities for Earth, Mars, and Jupiter. import numpy as np import matplotlib.pyplot as plt # Gravitational constant in m^3 kg^-1 s^-2 G = 6.67430e-11 # Celestial bodies' data (mass in kg, radius in meters) celestial_bodies = { \"Earth\": {\"mass\": 5.972e24, \"radius\": 6.371e6}, \"Mars\": {\"mass\": 0.64171e24, \"radius\": 3.396e6}, \"Jupiter\": {\"mass\": 1.898e27, \"radius\": 6.991e7}, } # Calculate Escape Velocity def escape_velocity(mass, radius): return np.sqrt(2 * G * mass / radius) # Calculate Orbital Velocity def orbital_velocity(mass, radius): return np.sqrt(G * mass / radius) # Third Cosmic Velocity (velocity to escape the solar system) def third_cosmic_velocity(mass, radius): # For third cosmic velocity, assume mass of Sun M_sun = 1.989e30 return np.sqrt(2 * G * M_sun / radius) # Prepare data for plotting escape_velocities = {} orbital_velocities = {} third_cosmic_velocities = {} for body, data in celestial_bodies.items(): escape_velocities[body] = escape_velocity(data[\"mass\"], data[\"radius\"]) orbital_velocities[body] = orbital_velocity(data[\"mass\"], data[\"radius\"]) third_cosmic_velocities[body] = third_cosmic_velocity(data[\"mass\"], data[\"radius\"]) # Plotting the results fig, ax = plt.subplots(figsize=(10, 6)) # Labels labels = list(celestial_bodies.keys()) # Velocities escape_vals = list(escape_velocities.values()) orbital_vals = list(orbital_velocities.values()) third_vals = list(third_cosmic_velocities.values()) # Plot each velocity ax.bar(labels, escape_vals, width=0.2, label='Escape Velocity', align='center') ax.bar(labels, orbital_vals, width=0.2, label='Orbital Velocity', align='edge') ax.bar(labels, third_vals, width=0.2, label='Third Cosmic Velocity', align='edge') # Labels and Title ax.set_xlabel('Celestial Bodies') ax.set_ylabel('Velocity (m/s)') ax.set_title('Escape Velocities and Cosmic Velocities for Different Celestial Bodies') ax.legend() # Show plot plt.tight_layout() plt.show() 5. Importance in Space Exploration Escape Velocity: This is essential for space missions. For instance, spacecraft need to achieve escape velocity to leave Earth\u2019s gravity and travel into space. Orbital Velocity: This velocity is necessary to place satellites in orbit around a celestial body. Communication, weather, and navigation satellites all rely on this velocity. Third Cosmic Velocity: This velocity is significant for interstellar exploration. For example, missions to send probes beyond the solar system require achieving the third cosmic velocity, allowing objects to leave the Sun's gravitational influence. 6. Conclusion This analysis and simulation help us understand the velocities required to escape or orbit celestial bodies and even travel beyond our solar system. These calculations are fundamental to modern space exploration, from launching satellites to planning interstellar missions.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-introduction","text":"The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions. In this document, we will define the first, second, and third cosmic velocities, analyze their mathematical derivations, and calculate and visualize these velocities for different celestial bodies like Earth, Mars, and Jupiter.","title":"1. Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-cosmic-velocities-overview","text":"","title":"2. Cosmic Velocities Overview"},{"location":"1%20Physics/2%20Gravity/Problem_2/#21-escape-velocity","text":"The escape velocity is the minimum speed an object must have to break free from a celestial body\u2019s gravitational pull without further propulsion. It depends on the mass and radius of the body.","title":"2.1 Escape Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#22-first-cosmic-velocity-orbital-velocity","text":"The first cosmic velocity is the velocity required for an object to enter a circular orbit around a celestial body. It is derived from balancing gravitational force with centripetal force.","title":"2.2 First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#23-second-cosmic-velocity-escape-velocity","text":"The second cosmic velocity is the velocity required for an object to escape the gravitational pull of a celestial body, traveling on a parabolic trajectory. It is the minimum velocity to overcome the gravitational force at the surface.","title":"2.3 Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#24-third-cosmic-velocity-interstellar-escape-velocity","text":"The third cosmic velocity is the velocity needed for an object to escape the gravitational influence of a star or planetary system, allowing it to travel into interstellar space.","title":"2.4 Third Cosmic Velocity (Interstellar Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-mathematical-derivations","text":"","title":"3. Mathematical Derivations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#31-escape-velocity-formula","text":"The escape velocity \\(v_e\\) from a celestial body is given by the formula: \\[v_e = \\sqrt{\\frac{2GM}{R}}\\] Where: \\(G\\) is the gravitational constant ($ 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\, \\text{kg}^{-1} \\, \\text{s}^{-2} $), \\(M\\) is the mass of the celestial body, \\(R\\) is the radius of the celestial body.","title":"3.1 Escape Velocity Formula"},{"location":"1%20Physics/2%20Gravity/Problem_2/#32-orbital-velocity-first-cosmic-velocity","text":"For a circular orbit, the orbital velocity \\(v_o\\) is: \\[v_o=\\sqrt{\\frac{GM}{R}}\\] This is the speed required to stay in orbit without falling into the celestial body.","title":"3.2 Orbital Velocity (First Cosmic Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#33-third-cosmic-velocity","text":"The third cosmic velocity \\(v_3\\) is the velocity required to escape the entire solar system (or a stellar system) and is given by: \\[v*3 = \\sqrt{\\frac{2GM*{sun}}{R}}\\] Where: \\(M\\_{sun}\\) is the mass of the Sun (or the central star of the system), \\(R\\) is the distance from the object to the center of the solar system.","title":"3.3 Third Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#4-implementation-and-visualization-in-python","text":"The following Python code implements these formulas and visualizes the escape velocities and cosmic velocities for Earth, Mars, and Jupiter. import numpy as np import matplotlib.pyplot as plt # Gravitational constant in m^3 kg^-1 s^-2 G = 6.67430e-11 # Celestial bodies' data (mass in kg, radius in meters) celestial_bodies = { \"Earth\": {\"mass\": 5.972e24, \"radius\": 6.371e6}, \"Mars\": {\"mass\": 0.64171e24, \"radius\": 3.396e6}, \"Jupiter\": {\"mass\": 1.898e27, \"radius\": 6.991e7}, } # Calculate Escape Velocity def escape_velocity(mass, radius): return np.sqrt(2 * G * mass / radius) # Calculate Orbital Velocity def orbital_velocity(mass, radius): return np.sqrt(G * mass / radius) # Third Cosmic Velocity (velocity to escape the solar system) def third_cosmic_velocity(mass, radius): # For third cosmic velocity, assume mass of Sun M_sun = 1.989e30 return np.sqrt(2 * G * M_sun / radius) # Prepare data for plotting escape_velocities = {} orbital_velocities = {} third_cosmic_velocities = {} for body, data in celestial_bodies.items(): escape_velocities[body] = escape_velocity(data[\"mass\"], data[\"radius\"]) orbital_velocities[body] = orbital_velocity(data[\"mass\"], data[\"radius\"]) third_cosmic_velocities[body] = third_cosmic_velocity(data[\"mass\"], data[\"radius\"]) # Plotting the results fig, ax = plt.subplots(figsize=(10, 6)) # Labels labels = list(celestial_bodies.keys()) # Velocities escape_vals = list(escape_velocities.values()) orbital_vals = list(orbital_velocities.values()) third_vals = list(third_cosmic_velocities.values()) # Plot each velocity ax.bar(labels, escape_vals, width=0.2, label='Escape Velocity', align='center') ax.bar(labels, orbital_vals, width=0.2, label='Orbital Velocity', align='edge') ax.bar(labels, third_vals, width=0.2, label='Third Cosmic Velocity', align='edge') # Labels and Title ax.set_xlabel('Celestial Bodies') ax.set_ylabel('Velocity (m/s)') ax.set_title('Escape Velocities and Cosmic Velocities for Different Celestial Bodies') ax.legend() # Show plot plt.tight_layout() plt.show()","title":"4. Implementation and Visualization in Python"},{"location":"1%20Physics/2%20Gravity/Problem_2/#5-importance-in-space-exploration","text":"Escape Velocity: This is essential for space missions. For instance, spacecraft need to achieve escape velocity to leave Earth\u2019s gravity and travel into space. Orbital Velocity: This velocity is necessary to place satellites in orbit around a celestial body. Communication, weather, and navigation satellites all rely on this velocity. Third Cosmic Velocity: This velocity is significant for interstellar exploration. For example, missions to send probes beyond the solar system require achieving the third cosmic velocity, allowing objects to leave the Sun's gravitational influence.","title":"5. Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#6-conclusion","text":"This analysis and simulation help us understand the velocities required to escape or orbit celestial bodies and even travel beyond our solar system. These calculations are fundamental to modern space exploration, from launching satellites to planning interstellar missions.","title":"6. Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth Motivation When a payload is released from a moving rocket near Earth, its future motion depends on initial speed, direction, and gravitational pull. Such situations are essential to understand for satellite deployment , orbital transfers , and safe reentry or escape missions. This problem blends gravitational physics , orbital mechanics , and numerical methods to simulate and predict these possible trajectories. Objective Analyze different types of trajectories: elliptical , parabolic , and hyperbolic . Simulate motion based on initial conditions like altitude, speed, and direction. Identify whether the object will orbit , fall back , or escape . Visualize and interpret results using Python simulations. Theoretical Foundation The object follows Newton\u2019s Law of Gravitation: \\[\\vec{F} = -\\frac{GMm}{r^2} \\hat{r}\\] Resulting in the acceleration: \\[\\vec{a} = -\\frac{GM}{r^2} \\hat{r}\\] Where: \\(G = 6.67430 \\times 10^{-11} \\, \\text{Nm}^2/\\text{kg}^2\\) \\(M =\\) mass of Earth \\(r =\\) distance from Earth\u2019s center The total energy \\(E\\) of the system determines the type of trajectory: \\(E < 0\\) \u2192 Elliptical Orbit \\(E = 0\\) \u2192 Parabolic Escape \\(E > 0\\) \u2192 Hyperbolic Escape Python Simulation import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # m^3/kg/s^2 M = 5.972e24 # kg (mass of Earth) R_earth = 6.371e6 # m # Define gravitational acceleration def gravity(t, y): x, vx, y_, vy = y r = np.sqrt(x**2 + y_**2) ax = -G * M * x / r**3 ay = -G * M * y_ / r**3 return [vx, ax, vy, ay] # Initial conditions altitude = 400e3 # 400 km above surface r0 = R_earth + altitude v_circular = np.sqrt(G * M / r0) # Try different velocities (suborbital, orbital, escape) initial_velocities = [0.9*v_circular, 1.0*v_circular, 1.2*v_circular] colors = ['blue', 'green', 'red'] labels = ['Suborbital', 'Orbital', 'Escape'] # Time span t_span = (0, 6000) # seconds t_eval = np.linspace(*t_span, 5000) plt.figure(figsize=(8, 8)) for v0, color, label in zip(initial_velocities, colors, labels): y0 = [r0, 0, 0, v0] # x, vx, y, vy sol = solve_ivp(gravity, t_span, y0, t_eval=t_eval, rtol=1e-8) x, y = sol.y[0], sol.y[2] plt.plot(x/1000, y/1000, color=color, label=label) # Earth circle = plt.Circle((0, 0), R_earth/1000, color='black', alpha=0.3) plt.gca().add_patch(circle) plt.xlabel(\"x (km)\") plt.ylabel(\"y (km)\") plt.title(\"Payload Trajectories Released Near Earth\") plt.legend() plt.axis(\"equal\") plt.grid(True) plt.tight_layout() plt.show()","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When a payload is released from a moving rocket near Earth, its future motion depends on initial speed, direction, and gravitational pull. Such situations are essential to understand for satellite deployment , orbital transfers , and safe reentry or escape missions. This problem blends gravitational physics , orbital mechanics , and numerical methods to simulate and predict these possible trajectories.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#objective","text":"Analyze different types of trajectories: elliptical , parabolic , and hyperbolic . Simulate motion based on initial conditions like altitude, speed, and direction. Identify whether the object will orbit , fall back , or escape . Visualize and interpret results using Python simulations.","title":"Objective"},{"location":"1%20Physics/2%20Gravity/Problem_3/#theoretical-foundation","text":"The object follows Newton\u2019s Law of Gravitation: \\[\\vec{F} = -\\frac{GMm}{r^2} \\hat{r}\\] Resulting in the acceleration: \\[\\vec{a} = -\\frac{GM}{r^2} \\hat{r}\\] Where: \\(G = 6.67430 \\times 10^{-11} \\, \\text{Nm}^2/\\text{kg}^2\\) \\(M =\\) mass of Earth \\(r =\\) distance from Earth\u2019s center The total energy \\(E\\) of the system determines the type of trajectory: \\(E < 0\\) \u2192 Elliptical Orbit \\(E = 0\\) \u2192 Parabolic Escape \\(E > 0\\) \u2192 Hyperbolic Escape","title":"Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-simulation","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # m^3/kg/s^2 M = 5.972e24 # kg (mass of Earth) R_earth = 6.371e6 # m # Define gravitational acceleration def gravity(t, y): x, vx, y_, vy = y r = np.sqrt(x**2 + y_**2) ax = -G * M * x / r**3 ay = -G * M * y_ / r**3 return [vx, ax, vy, ay] # Initial conditions altitude = 400e3 # 400 km above surface r0 = R_earth + altitude v_circular = np.sqrt(G * M / r0) # Try different velocities (suborbital, orbital, escape) initial_velocities = [0.9*v_circular, 1.0*v_circular, 1.2*v_circular] colors = ['blue', 'green', 'red'] labels = ['Suborbital', 'Orbital', 'Escape'] # Time span t_span = (0, 6000) # seconds t_eval = np.linspace(*t_span, 5000) plt.figure(figsize=(8, 8)) for v0, color, label in zip(initial_velocities, colors, labels): y0 = [r0, 0, 0, v0] # x, vx, y, vy sol = solve_ivp(gravity, t_span, y0, t_eval=t_eval, rtol=1e-8) x, y = sol.y[0], sol.y[2] plt.plot(x/1000, y/1000, color=color, label=label) # Earth circle = plt.Circle((0, 0), R_earth/1000, color='black', alpha=0.3) plt.gca().add_patch(circle) plt.xlabel(\"x (km)\") plt.ylabel(\"y (km)\") plt.title(\"Payload Trajectories Released Near Earth\") plt.legend() plt.axis(\"equal\") plt.grid(True) plt.tight_layout() plt.show()","title":"Python Simulation"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Interference Patterns from Multiple Wave Sources Motivation When multiple wave sources interact, the resulting pattern reveals the rich behavior of wave interference . This phenomenon is central to understanding light, sound, and even quantum behavior. By studying how waves from different sources superimpose on a water surface, we explore constructive and destructive interference , which form beautiful and physically meaningful patterns. This simulation offers a hands-on way to visualize and understand the effects of phase relationships and spatial arrangement on interference, laying a foundation for real-world applications like antenna design , acoustics , and optics . Objective Analyze interference from coherent wave sources placed at the vertices of a regular polygon (e.g., square). Apply the principle of superposition to calculate total displacement at any point. Use simulation to visualize regions of constructive and destructive interference. Understand the influence of geometric symmetry on wave interaction. Theoretical Foundation Circular Wave Equation A circular wave from a single point source is modeled as: \\[ y(x, y, t) = A \\sin(kr - \\omega t + \\phi) \\] Where: \\(A\\) : amplitude \\(r=\\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) : distance from the source \\(k =\\frac{2\\pi}{\\lambda}\\) : wave number \\(\\omega = 2\\pi f\\) : angular frequency \\(\\phi\\) : initial phase Superposition of Multiple Sources For \\(N\\) coherent sources: \\[ y_{\\text{total}}(x, y, t) = \\sum_{i=1}^{N} A \\sin(k r_i - \\omega t) \\] This produces interference patterns where wave crests align (constructive) or cancel (destructive). Constructive & Destructive Interference Constructive : \\(\\Delta r = m \\lambda\\) (waves in phase) Destructive : \\(\\Delta r = (m + 0.5)\\lambda\\) (waves out of phase) These lead to alternating regions of high and low displacement. Polygonal Source Arrangement Using a square configuration ensures symmetry, helping us observe consistent interference patterns. The geometry influences how and where constructive and destructive interference occurs. Python Simulation: Square Configuration import numpy as np import matplotlib.pyplot as plt # Parameters A = 1.0 \u03bb = 1.0 f = 1.0 k = 2 * np.pi / \u03bb \u03c9 = 2 * np.pi * f \u03c6 = 0 t = 0 x = np.linspace(-5, 5, 500) y = np.linspace(-5, 5, 500) X, Y = np.meshgrid(x, y) # Square vertices R = 2 num_sources = 4 angles = np.linspace(0, 2 * np.pi, num_sources, endpoint=False) sources = [(R * np.cos(a), R * np.sin(a)) for a in angles] Z = np.zeros_like(X) for (sx, sy) in sources: r = np.sqrt((X - sx)**2 + (Y - sy)**2) Z += A * np.sin(k * r - \u03c9 * t + \u03c6) plt.figure(figsize=(8, 6)) plt.contourf(X, Y, Z, levels=100, cmap='viridis') plt.colorbar(label='Displacement') plt.title('Wave Interference Pattern (Square Sources)') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.tight_layout() plt.show()","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-from-multiple-wave-sources","text":"","title":"Interference Patterns from Multiple Wave Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#motivation","text":"When multiple wave sources interact, the resulting pattern reveals the rich behavior of wave interference . This phenomenon is central to understanding light, sound, and even quantum behavior. By studying how waves from different sources superimpose on a water surface, we explore constructive and destructive interference , which form beautiful and physically meaningful patterns. This simulation offers a hands-on way to visualize and understand the effects of phase relationships and spatial arrangement on interference, laying a foundation for real-world applications like antenna design , acoustics , and optics .","title":"Motivation"},{"location":"1%20Physics/3%20Waves/Problem_1/#objective","text":"Analyze interference from coherent wave sources placed at the vertices of a regular polygon (e.g., square). Apply the principle of superposition to calculate total displacement at any point. Use simulation to visualize regions of constructive and destructive interference. Understand the influence of geometric symmetry on wave interaction.","title":"Objective"},{"location":"1%20Physics/3%20Waves/Problem_1/#theoretical-foundation","text":"","title":"Theoretical Foundation"},{"location":"1%20Physics/3%20Waves/Problem_1/#circular-wave-equation","text":"A circular wave from a single point source is modeled as: \\[ y(x, y, t) = A \\sin(kr - \\omega t + \\phi) \\] Where: \\(A\\) : amplitude \\(r=\\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) : distance from the source \\(k =\\frac{2\\pi}{\\lambda}\\) : wave number \\(\\omega = 2\\pi f\\) : angular frequency \\(\\phi\\) : initial phase","title":"Circular Wave Equation"},{"location":"1%20Physics/3%20Waves/Problem_1/#superposition-of-multiple-sources","text":"For \\(N\\) coherent sources: \\[ y_{\\text{total}}(x, y, t) = \\sum_{i=1}^{N} A \\sin(k r_i - \\omega t) \\] This produces interference patterns where wave crests align (constructive) or cancel (destructive).","title":"Superposition of Multiple Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#constructive-destructive-interference","text":"Constructive : \\(\\Delta r = m \\lambda\\) (waves in phase) Destructive : \\(\\Delta r = (m + 0.5)\\lambda\\) (waves out of phase) These lead to alternating regions of high and low displacement.","title":"Constructive &amp; Destructive Interference"},{"location":"1%20Physics/3%20Waves/Problem_1/#polygonal-source-arrangement","text":"Using a square configuration ensures symmetry, helping us observe consistent interference patterns. The geometry influences how and where constructive and destructive interference occurs.","title":"Polygonal Source Arrangement"},{"location":"1%20Physics/3%20Waves/Problem_1/#python-simulation-square-configuration","text":"import numpy as np import matplotlib.pyplot as plt # Parameters A = 1.0 \u03bb = 1.0 f = 1.0 k = 2 * np.pi / \u03bb \u03c9 = 2 * np.pi * f \u03c6 = 0 t = 0 x = np.linspace(-5, 5, 500) y = np.linspace(-5, 5, 500) X, Y = np.meshgrid(x, y) # Square vertices R = 2 num_sources = 4 angles = np.linspace(0, 2 * np.pi, num_sources, endpoint=False) sources = [(R * np.cos(a), R * np.sin(a)) for a in angles] Z = np.zeros_like(X) for (sx, sy) in sources: r = np.sqrt((X - sx)**2 + (Y - sy)**2) Z += A * np.sin(k * r - \u03c9 * t + \u03c6) plt.figure(figsize=(8, 6)) plt.contourf(X, Y, Z, levels=100, cmap='viridis') plt.colorbar(label='Displacement') plt.title('Wave Interference Pattern (Square Sources)') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.tight_layout() plt.show()","title":"Python Simulation: Square Configuration"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 Simulating the Effects of the Lorentz Force Motivation The Lorentz force governs the motion of charged particles in the presence of electric and magnetic fields. It is central to understanding systems such as: Particle accelerators (e.g., cyclotrons, synchrotrons) Mass spectrometers Plasma confinement devices (e.g., tokamaks, magnetic bottles) Charged particle beams in space and astrophysics By simulating the Lorentz force, we gain insight into how particles move under various field conditions, observe behaviors like circular or helical motion, and understand applications like velocity selectors or drift tubes. Objective Simulate the trajectory of a charged particle under different field configurations. Visualize motion in 2D/3D to observe patterns such as circular , helical , or drift trajectories. Explore how field strength , initial velocity , mass , and charge influence the motion. Methodology We use the Lorentz force law: \\[ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] The resulting equations of motion are: \\[m \\frac{d\\vec{v}}{dt} = q(\\vec{E} + \\vec{v} \\times \\vec{B})\\] \\[\\frac{d\\vec{r}}{dt} = \\vec{v}\\] To numerically solve these coupled equations, we use the Runge-Kutta 4th-order method (RK4) for better stability and accuracy. Python Code: Particle Trajectory in E and B Fields import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants and initial parameters q = 1.0 # Charge m = 1.0 # Mass v0 = np.array([1.0, 0.0, 0.0]) # Initial velocity r0 = np.array([0.0, 0.0, 0.0]) # Initial position E = np.array([0.0, 0.0, 0.0]) # Electric field B = np.array([0.0, 0.0, 1.0]) # Magnetic field dt = 0.01 steps = 3000 # Storage arrays positions = [r0] velocities = [v0] # RK4 integration def lorentz_force(v, E, B): return (q / m) * (E + np.cross(v, B)) for _ in range(steps): r = positions[-1] v = velocities[-1] k1v = lorentz_force(v, E, B) * dt k1r = v * dt k2v = lorentz_force(v + 0.5 * k1v, E, B) * dt k2r = (v + 0.5 * k1v) * dt k3v = lorentz_force(v + 0.5 * k2v, E, B) * dt k3r = (v + 0.5 * k2v) * dt k4v = lorentz_force(v + k3v, E, B) * dt k4r = (v + k3v) * dt v_new = v + (1/6)*(k1v + 2*k2v + 2*k3v + k4v) r_new = r + (1/6)*(k1r + 2*k2r + 2*k3r + k4r) velocities.append(v_new) positions.append(r_new) positions = np.array(positions) # 3D Trajectory Plot fig = plt.figure(figsize=(10, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(positions[:, 0], positions[:, 1], positions[:, 2]) ax.set_title(\"Particle Trajectory Under Uniform Magnetic Field\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") ax.set_zlabel(\"z\") plt.tight_layout() plt.show() Simulation Result In a uniform magnetic field, the charged particle follows a helical path. The radius of the circular component (Larmor radius) depends on velocity and magnetic field strength: \\[\ud835\udc5f\ud835\udc3f=\ud835\udc53\ud835\udc5f\ud835\udc4e\ud835\udc50\ud835\udc5a\ud835\udc63\u22a5\u2223\ud835\udc5e\ud835\udc35\u2223 rL=fracmv \u22a5 \u2223qB\u2223\\] The pitch of the helix depends on the component of velocity along the field. Applications and Extensions Adding a constant electric field creates E \u00d7 B drift, where the particle drifts perpendicular to both fields. The simulation can be extended to: Non-uniform fields (e.g., magnetic mirrors) Multiple particles (plasma dynamics) Collisions or interactions (Monte Carlo models) This simulation provides an intuitive understanding of the Lorentz force, complementing theory with visualization and encouraging deeper exploration.","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulating-the-effects-of-the-lorentz-force","text":"","title":"Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#motivation","text":"The Lorentz force governs the motion of charged particles in the presence of electric and magnetic fields. It is central to understanding systems such as: Particle accelerators (e.g., cyclotrons, synchrotrons) Mass spectrometers Plasma confinement devices (e.g., tokamaks, magnetic bottles) Charged particle beams in space and astrophysics By simulating the Lorentz force, we gain insight into how particles move under various field conditions, observe behaviors like circular or helical motion, and understand applications like velocity selectors or drift tubes.","title":"Motivation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#objective","text":"Simulate the trajectory of a charged particle under different field configurations. Visualize motion in 2D/3D to observe patterns such as circular , helical , or drift trajectories. Explore how field strength , initial velocity , mass , and charge influence the motion.","title":"Objective"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#methodology","text":"We use the Lorentz force law: \\[ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] The resulting equations of motion are: \\[m \\frac{d\\vec{v}}{dt} = q(\\vec{E} + \\vec{v} \\times \\vec{B})\\] \\[\\frac{d\\vec{r}}{dt} = \\vec{v}\\] To numerically solve these coupled equations, we use the Runge-Kutta 4th-order method (RK4) for better stability and accuracy.","title":"Methodology"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#python-code-particle-trajectory-in-e-and-b-fields","text":"import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants and initial parameters q = 1.0 # Charge m = 1.0 # Mass v0 = np.array([1.0, 0.0, 0.0]) # Initial velocity r0 = np.array([0.0, 0.0, 0.0]) # Initial position E = np.array([0.0, 0.0, 0.0]) # Electric field B = np.array([0.0, 0.0, 1.0]) # Magnetic field dt = 0.01 steps = 3000 # Storage arrays positions = [r0] velocities = [v0] # RK4 integration def lorentz_force(v, E, B): return (q / m) * (E + np.cross(v, B)) for _ in range(steps): r = positions[-1] v = velocities[-1] k1v = lorentz_force(v, E, B) * dt k1r = v * dt k2v = lorentz_force(v + 0.5 * k1v, E, B) * dt k2r = (v + 0.5 * k1v) * dt k3v = lorentz_force(v + 0.5 * k2v, E, B) * dt k3r = (v + 0.5 * k2v) * dt k4v = lorentz_force(v + k3v, E, B) * dt k4r = (v + k3v) * dt v_new = v + (1/6)*(k1v + 2*k2v + 2*k3v + k4v) r_new = r + (1/6)*(k1r + 2*k2r + 2*k3r + k4r) velocities.append(v_new) positions.append(r_new) positions = np.array(positions) # 3D Trajectory Plot fig = plt.figure(figsize=(10, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(positions[:, 0], positions[:, 1], positions[:, 2]) ax.set_title(\"Particle Trajectory Under Uniform Magnetic Field\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") ax.set_zlabel(\"z\") plt.tight_layout() plt.show()","title":"Python Code: Particle Trajectory in E and B Fields"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulation-result","text":"In a uniform magnetic field, the charged particle follows a helical path. The radius of the circular component (Larmor radius) depends on velocity and magnetic field strength: \\[\ud835\udc5f\ud835\udc3f=\ud835\udc53\ud835\udc5f\ud835\udc4e\ud835\udc50\ud835\udc5a\ud835\udc63\u22a5\u2223\ud835\udc5e\ud835\udc35\u2223 rL=fracmv \u22a5 \u2223qB\u2223\\] The pitch of the helix depends on the component of velocity along the field.","title":"Simulation Result"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#applications-and-extensions","text":"Adding a constant electric field creates E \u00d7 B drift, where the particle drifts perpendicular to both fields. The simulation can be extended to: Non-uniform fields (e.g., magnetic mirrors) Multiple particles (plasma dynamics) Collisions or interactions (Monte Carlo models) This simulation provides an intuitive understanding of the Lorentz force, complementing theory with visualization and encouraging deeper exploration.","title":"Applications and Extensions"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 Equivalent Resistance Using Graph Theory Motivation Calculating equivalent resistance is a fundamental task in circuit analysis, critical for designing efficient electrical and electronic systems. Traditional methods involving series-parallel simplification become challenging for large or nested circuits. Graph theory provides a systematic and scalable approach to simplify and analyze such resistor networks. By representing circuits as graphs\u2014with nodes as junctions and edges as resistors\u2014we can leverage mathematical tools like Laplacian matrices and linear algebra to compute equivalent resistance algorithmically. This opens the door to automation, optimization, and deep theoretical insights across physics, electrical engineering, and computer science. Objective Represent resistor circuits as weighted graphs. Use graph-theoretical methods to compute the equivalent resistance between two nodes. Support arbitrary resistor configurations, including series, parallel, and nested combinations. Visualize the network and validate results with numerical computation. Methodology Model the circuit as an undirected graph where edge weights represent resistance. Construct the Laplacian matrix of the graph. Compute the Moore-Penrose pseudoinverse of the Laplacian matrix. Apply the resistance distance formula to find the equivalent resistance between two nodes. Theoretical Foundation In graph theory, the equivalent resistance $ R_{ij} $ between two nodes \\(i\\) and \\(j\\) in a resistor network is given by: \\[ R_{ij} = L^+_{ii} + L^+_{jj} - 2L^+_{ij} \\] Where: \\(L\\) is the Laplacian matrix of the graph, \\(L^+\\) is the pseudoinverse of the Laplacian matrix, The graph must be connected and resistors must have positive weights. This method captures all possible paths and their contributions, including parallel paths and cycles, in a single unified formula. Python Code: Graph Construction & Resistance Calculation import networkx as nx import matplotlib.pyplot as plt import numpy as np # Define a function to calculate equivalent resistance def calculate_equivalent_resistance(G, source, target): L = nx.laplacian_matrix(G, weight='resistance').astype(float).todense() L_pinv = np.linalg.pinv(L) R_eq = L_pinv[source, source] + L_pinv[target, target] - 2 * L_pinv[source, target] return R_eq # Create the graph G = nx.Graph() G.add_nodes_from(range(5)) edges = [ (0, 1, 2), # 2\u03a9 (1, 2, 3), # 3\u03a9 (0, 2, 6), # 6\u03a9 (2, 3, 1), # 1\u03a9 (3, 4, 2) # 2\u03a9 ] for u, v, r in edges: G.add_edge(u, v, resistance=r) # Visualize the graph pos = nx.spring_layout(G, seed=42) edge_labels = nx.get_edge_attributes(G, 'resistance') plt.figure(figsize=(8, 6)) nx.draw(G, pos, with_labels=True, node_color='lightblue', node_size=800, font_size=12) nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_color='red') plt.title(\"Resistor Network Graph\") plt.tight_layout() plt.show() # Calculate equivalent resistance R_eq = calculate_equivalent_resistance(G, 0, 2) print(f\"Equivalent resistance between node 0 and node 2: {R_eq:.3f} \u03a9\") Simulation Result The equivalent resistance computed between node 0 and node 2 is: \\(\ud835\udc45\ud835\udc52\ud835\udc5e\u22480.139\\) \\(\u03a9 R eq \u22480.139\u03a9\\) This low resistance arises from multiple parallel paths through nodes 1 and 3. Conclusion Graph theory offers a robust and scalable way to calculate equivalent resistance. It captures the effect of all paths (including cycles) automatically via matrix computation. This method is particularly valuable for complex, nested, or dynamically changing networks. Combined with tools like NetworkX, it enables fast simulation, visualization, and analysis.","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#equivalent-resistance-using-graph-theory","text":"","title":"Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#motivation","text":"Calculating equivalent resistance is a fundamental task in circuit analysis, critical for designing efficient electrical and electronic systems. Traditional methods involving series-parallel simplification become challenging for large or nested circuits. Graph theory provides a systematic and scalable approach to simplify and analyze such resistor networks. By representing circuits as graphs\u2014with nodes as junctions and edges as resistors\u2014we can leverage mathematical tools like Laplacian matrices and linear algebra to compute equivalent resistance algorithmically. This opens the door to automation, optimization, and deep theoretical insights across physics, electrical engineering, and computer science.","title":"Motivation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#objective","text":"Represent resistor circuits as weighted graphs. Use graph-theoretical methods to compute the equivalent resistance between two nodes. Support arbitrary resistor configurations, including series, parallel, and nested combinations. Visualize the network and validate results with numerical computation.","title":"Objective"},{"location":"1%20Physics/5%20Circuits/Problem_1/#methodology","text":"Model the circuit as an undirected graph where edge weights represent resistance. Construct the Laplacian matrix of the graph. Compute the Moore-Penrose pseudoinverse of the Laplacian matrix. Apply the resistance distance formula to find the equivalent resistance between two nodes.","title":"Methodology"},{"location":"1%20Physics/5%20Circuits/Problem_1/#theoretical-foundation","text":"In graph theory, the equivalent resistance $ R_{ij} $ between two nodes \\(i\\) and \\(j\\) in a resistor network is given by: \\[ R_{ij} = L^+_{ii} + L^+_{jj} - 2L^+_{ij} \\] Where: \\(L\\) is the Laplacian matrix of the graph, \\(L^+\\) is the pseudoinverse of the Laplacian matrix, The graph must be connected and resistors must have positive weights. This method captures all possible paths and their contributions, including parallel paths and cycles, in a single unified formula.","title":"Theoretical Foundation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#python-code-graph-construction-resistance-calculation","text":"import networkx as nx import matplotlib.pyplot as plt import numpy as np # Define a function to calculate equivalent resistance def calculate_equivalent_resistance(G, source, target): L = nx.laplacian_matrix(G, weight='resistance').astype(float).todense() L_pinv = np.linalg.pinv(L) R_eq = L_pinv[source, source] + L_pinv[target, target] - 2 * L_pinv[source, target] return R_eq # Create the graph G = nx.Graph() G.add_nodes_from(range(5)) edges = [ (0, 1, 2), # 2\u03a9 (1, 2, 3), # 3\u03a9 (0, 2, 6), # 6\u03a9 (2, 3, 1), # 1\u03a9 (3, 4, 2) # 2\u03a9 ] for u, v, r in edges: G.add_edge(u, v, resistance=r) # Visualize the graph pos = nx.spring_layout(G, seed=42) edge_labels = nx.get_edge_attributes(G, 'resistance') plt.figure(figsize=(8, 6)) nx.draw(G, pos, with_labels=True, node_color='lightblue', node_size=800, font_size=12) nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_color='red') plt.title(\"Resistor Network Graph\") plt.tight_layout() plt.show() # Calculate equivalent resistance R_eq = calculate_equivalent_resistance(G, 0, 2) print(f\"Equivalent resistance between node 0 and node 2: {R_eq:.3f} \u03a9\")","title":"Python Code: Graph Construction &amp; Resistance Calculation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#simulation-result","text":"The equivalent resistance computed between node 0 and node 2 is: \\(\ud835\udc45\ud835\udc52\ud835\udc5e\u22480.139\\) \\(\u03a9 R eq \u22480.139\u03a9\\) This low resistance arises from multiple parallel paths through nodes 1 and 3.","title":"Simulation Result"},{"location":"1%20Physics/5%20Circuits/Problem_1/#conclusion","text":"Graph theory offers a robust and scalable way to calculate equivalent resistance. It captures the effect of all paths (including cycles) automatically via matrix computation. This method is particularly valuable for complex, nested, or dynamically changing networks. Combined with tools like NetworkX, it enables fast simulation, visualization, and analysis.","title":"Conclusion"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1 Exploring the Central Limit Theorem Through Simulations Motivation The Central Limit Theorem (CLT) is a fundamental result in probability and statistics. It states that, for a sufficiently large sample size, the sampling distribution of the sample mean becomes approximately normal, regardless of the original population distribution. This concept is essential in: Estimating population parameters from sample data. Designing statistical quality control systems. Modeling aggregate outcomes in finance and economics. Simulations offer an intuitive, visual way to see the CLT in action and understand its power in real-world contexts. Objective Demonstrate the Central Limit Theorem using simulations. Show how the sample mean distribution evolves as sample size increases. Compare the rate of convergence for different population distributions. Visualize results to build a strong conceptual understanding. Methodology Select multiple population distributions: Uniform(0, 1) Exponential(\u03bb = 1) Binomial(n = 10, p = 0.5) For each distribution: Generate 1000 sample means for each sample size: 5, 10, 30, 50 Plot histograms of the sampling distributions Observe the shape of these histograms as the sample size increases. Python Code: Simulating the CLT import numpy as np import matplotlib.pyplot as plt import seaborn as sns import os # Simulation settings sample_sizes = [5, 10, 30, 50] num_samples = 1000 distributions = { \"Uniform(0, 1)\": lambda n: np.random.uniform(0, 1, size=n), \"Exponential(\u03bb=1)\": lambda n: np.random.exponential(scale=1.0, size=n), \"Binomial(n=10, p=0.5)\": lambda n: np.random.binomial(n=10, p=0.5, size=n), } # Plotting sampling distributions for each population and sample size for dist_name, dist_func in distributions.items(): plt.figure(figsize=(16, 10)) for i, n in enumerate(sample_sizes, 1): sample_means = [np.mean(dist_func(n)) for _ in range(num_samples)] plt.subplot(2, 2, i) sns.histplot(sample_means, kde=True, stat='density', bins=30, color='skyblue') plt.title(f\"{dist_name} - Sample size: {n}\") plt.xlabel(\"Sample Mean\") plt.ylabel(\"Density\") plt.suptitle(f\"Sampling Distributions of the Sample Mean\\\\nPopulation: {dist_name}\", fontsize=16) plt.tight_layout(rect=[0, 0.03, 1, 0.95]) plt.show() Interpretation and Observations Small sample sizes retain the shape of the parent distribution. Larger samples result in more normally distributed sample means. The rate of convergence depends on how skewed the original population is: Uniform \u2192 Fast convergence Exponential \u2192 Slower convergence due to skew Binomial \u2192 Intermediate, depending on parameters Real-World Applications Quality Control: Sampling the mean output of machines to monitor defects. Polls and Surveys: Estimating the population average from a sample. Risk Analysis: Modeling uncertainty in financial returns and projections. Conclusion The Central Limit Theorem demonstrates the power of aggregation. No matter the population's shape, the average of many samples behaves predictably. This allows for robust inference and underpins much of statistical theory and practice. Simulations help internalize this principle and appreciate its relevance to nearly every field involving data.","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#exploring-the-central-limit-theorem-through-simulations","text":"","title":"Exploring the Central Limit Theorem Through Simulations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#motivation","text":"The Central Limit Theorem (CLT) is a fundamental result in probability and statistics. It states that, for a sufficiently large sample size, the sampling distribution of the sample mean becomes approximately normal, regardless of the original population distribution. This concept is essential in: Estimating population parameters from sample data. Designing statistical quality control systems. Modeling aggregate outcomes in finance and economics. Simulations offer an intuitive, visual way to see the CLT in action and understand its power in real-world contexts.","title":"Motivation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#objective","text":"Demonstrate the Central Limit Theorem using simulations. Show how the sample mean distribution evolves as sample size increases. Compare the rate of convergence for different population distributions. Visualize results to build a strong conceptual understanding.","title":"Objective"},{"location":"1%20Physics/6%20Statistics/Problem_1/#methodology","text":"Select multiple population distributions: Uniform(0, 1) Exponential(\u03bb = 1) Binomial(n = 10, p = 0.5) For each distribution: Generate 1000 sample means for each sample size: 5, 10, 30, 50 Plot histograms of the sampling distributions Observe the shape of these histograms as the sample size increases.","title":"Methodology"},{"location":"1%20Physics/6%20Statistics/Problem_1/#python-code-simulating-the-clt","text":"import numpy as np import matplotlib.pyplot as plt import seaborn as sns import os # Simulation settings sample_sizes = [5, 10, 30, 50] num_samples = 1000 distributions = { \"Uniform(0, 1)\": lambda n: np.random.uniform(0, 1, size=n), \"Exponential(\u03bb=1)\": lambda n: np.random.exponential(scale=1.0, size=n), \"Binomial(n=10, p=0.5)\": lambda n: np.random.binomial(n=10, p=0.5, size=n), } # Plotting sampling distributions for each population and sample size for dist_name, dist_func in distributions.items(): plt.figure(figsize=(16, 10)) for i, n in enumerate(sample_sizes, 1): sample_means = [np.mean(dist_func(n)) for _ in range(num_samples)] plt.subplot(2, 2, i) sns.histplot(sample_means, kde=True, stat='density', bins=30, color='skyblue') plt.title(f\"{dist_name} - Sample size: {n}\") plt.xlabel(\"Sample Mean\") plt.ylabel(\"Density\") plt.suptitle(f\"Sampling Distributions of the Sample Mean\\\\nPopulation: {dist_name}\", fontsize=16) plt.tight_layout(rect=[0, 0.03, 1, 0.95]) plt.show()","title":"Python Code: Simulating the CLT"},{"location":"1%20Physics/6%20Statistics/Problem_1/#interpretation-and-observations","text":"Small sample sizes retain the shape of the parent distribution. Larger samples result in more normally distributed sample means. The rate of convergence depends on how skewed the original population is: Uniform \u2192 Fast convergence Exponential \u2192 Slower convergence due to skew Binomial \u2192 Intermediate, depending on parameters","title":"Interpretation and Observations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#real-world-applications","text":"Quality Control: Sampling the mean output of machines to monitor defects. Polls and Surveys: Estimating the population average from a sample. Risk Analysis: Modeling uncertainty in financial returns and projections.","title":"Real-World Applications"},{"location":"1%20Physics/6%20Statistics/Problem_1/#conclusion","text":"The Central Limit Theorem demonstrates the power of aggregation. No matter the population's shape, the average of many samples behaves predictably. This allows for robust inference and underpins much of statistical theory and practice. Simulations help internalize this principle and appreciate its relevance to nearly every field involving data.","title":"Conclusion"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2 Estimating \u03c0 Using Monte Carlo Methods Motivation Monte Carlo methods use randomness to solve mathematical problems that might be deterministic in principle. One elegant use of Monte Carlo simulation is to estimate the value of \u03c0 using simple geometric probability or classic experiments like Buffon\u2019s Needle . These methods offer an intuitive connection between probability, geometry, and computation \u2014 and have real applications in physics, finance, and algorithm design. Objective Estimate \u03c0 using two Monte Carlo approaches: Random point generation in a circle Buffon\u2019s Needle experiment Explore how convergence improves with sample size Visualize the estimation process Compare their accuracy and efficiency Theoretical Foundation Buffon\u2019s Needle Buffon\u2019s Needle is one of the oldest problems in geometric probability . Suppose we drop a needle of length \\(L\\) onto a plane ruled with parallel lines a distance \\(d\\) apart. The probability \\(P\\) that the needle crosses a line is: \\[P = \\frac{2L}{\\pi d}\\] Solving for \\(\\pi\\) , we estimate: \\[\\pi \\approx \\frac{2L \\cdot N}{C \\cdot d}\\] Where: \\(N\\) : total number of needle drops \\(C\\) : number of times the needle crosses a line \\(L\\) : length of the needle \\(d\\) : distance between lines Simulation: import numpy as np import matplotlib.pyplot as plt # Parameters n_drops = 10000 needle_length = 1.0 line_spacing = 1.0 crosses = 0 x_cross, y_cross = [], [] x_no_cross, y_no_cross = [], [] for _ in range(n_drops): x_center = np.random.uniform(0, line_spacing / 2) theta = np.random.uniform(0, np.pi) x_tip = (needle_length / 2) * np.cos(theta) if x_center <= x_tip: crosses += 1 x_cross.append(x_center) y_cross.append(theta) else: x_no_cross.append(x_center) y_no_cross.append(theta) # Estimate \u03c0 if crosses > 0: pi_estimate = (2 * needle_length * n_drops) / (crosses * line_spacing) else: pi_estimate = None # Plot the result plt.figure(figsize=(8, 6)) plt.title(f\"Buffon's Needle Simulation (N={n_drops})\\\\nEstimated \u03c0 \u2248 {pi_estimate:.5f}\") plt.scatter(x_cross, y_cross, s=10, color=\"green\", label=\"Crosses\") plt.scatter(x_no_cross, y_no_cross, s=10, color=\"red\", label=\"No Cross\") plt.axvline(line_spacing / 2, color='black', linestyle='--') plt.xlim(0, line_spacing) plt.ylim(0, np.pi) plt.xlabel(\"x (center position)\") plt.ylabel(\"\u03b8 (needle angle)\") plt.legend() plt.tight_layout() plt.show() Conclusion Monte Carlo simulations offer a creative, visual, and statistical approach to estimating \u03c0 using randomness. This project explored two distinct methods: Circle-based sampling : Fast and geometrically intuitive. The approximation converges quickly with more points and is easy to visualize. Buffon\u2019s Needle : A classical probabilistic method with deeper historical roots. Although less efficient, it beautifully demonstrates how geometry and randomness can work together to reveal fundamental constants. Through both simulations, we see the strength of Monte Carlo methods in tackling problems that blend theory, computation, and randomness. The convergence trends show that while simple, these methods are powerful tools for understanding the law of large numbers, probability distributions, and numerical estimation. \u03c0, a constant discovered through circles, reappears through needles and points \u2014 a poetic reminder of the interconnectedness of math and nature.","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#estimating-using-monte-carlo-methods","text":"","title":"Estimating \u03c0 Using Monte Carlo Methods"},{"location":"1%20Physics/6%20Statistics/Problem_2/#motivation","text":"Monte Carlo methods use randomness to solve mathematical problems that might be deterministic in principle. One elegant use of Monte Carlo simulation is to estimate the value of \u03c0 using simple geometric probability or classic experiments like Buffon\u2019s Needle . These methods offer an intuitive connection between probability, geometry, and computation \u2014 and have real applications in physics, finance, and algorithm design.","title":"Motivation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#objective","text":"Estimate \u03c0 using two Monte Carlo approaches: Random point generation in a circle Buffon\u2019s Needle experiment Explore how convergence improves with sample size Visualize the estimation process Compare their accuracy and efficiency","title":"Objective"},{"location":"1%20Physics/6%20Statistics/Problem_2/#theoretical-foundation","text":"","title":"Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#buffons-needle","text":"Buffon\u2019s Needle is one of the oldest problems in geometric probability . Suppose we drop a needle of length \\(L\\) onto a plane ruled with parallel lines a distance \\(d\\) apart. The probability \\(P\\) that the needle crosses a line is: \\[P = \\frac{2L}{\\pi d}\\] Solving for \\(\\pi\\) , we estimate: \\[\\pi \\approx \\frac{2L \\cdot N}{C \\cdot d}\\] Where: \\(N\\) : total number of needle drops \\(C\\) : number of times the needle crosses a line \\(L\\) : length of the needle \\(d\\) : distance between lines","title":"Buffon\u2019s Needle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#simulation","text":"import numpy as np import matplotlib.pyplot as plt # Parameters n_drops = 10000 needle_length = 1.0 line_spacing = 1.0 crosses = 0 x_cross, y_cross = [], [] x_no_cross, y_no_cross = [], [] for _ in range(n_drops): x_center = np.random.uniform(0, line_spacing / 2) theta = np.random.uniform(0, np.pi) x_tip = (needle_length / 2) * np.cos(theta) if x_center <= x_tip: crosses += 1 x_cross.append(x_center) y_cross.append(theta) else: x_no_cross.append(x_center) y_no_cross.append(theta) # Estimate \u03c0 if crosses > 0: pi_estimate = (2 * needle_length * n_drops) / (crosses * line_spacing) else: pi_estimate = None # Plot the result plt.figure(figsize=(8, 6)) plt.title(f\"Buffon's Needle Simulation (N={n_drops})\\\\nEstimated \u03c0 \u2248 {pi_estimate:.5f}\") plt.scatter(x_cross, y_cross, s=10, color=\"green\", label=\"Crosses\") plt.scatter(x_no_cross, y_no_cross, s=10, color=\"red\", label=\"No Cross\") plt.axvline(line_spacing / 2, color='black', linestyle='--') plt.xlim(0, line_spacing) plt.ylim(0, np.pi) plt.xlabel(\"x (center position)\") plt.ylabel(\"\u03b8 (needle angle)\") plt.legend() plt.tight_layout() plt.show()","title":"Simulation:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#conclusion","text":"Monte Carlo simulations offer a creative, visual, and statistical approach to estimating \u03c0 using randomness. This project explored two distinct methods: Circle-based sampling : Fast and geometrically intuitive. The approximation converges quickly with more points and is easy to visualize. Buffon\u2019s Needle : A classical probabilistic method with deeper historical roots. Although less efficient, it beautifully demonstrates how geometry and randomness can work together to reveal fundamental constants. Through both simulations, we see the strength of Monte Carlo methods in tackling problems that blend theory, computation, and randomness. The convergence trends show that while simple, these methods are powerful tools for understanding the law of large numbers, probability distributions, and numerical estimation. \u03c0, a constant discovered through circles, reappears through needles and points \u2014 a poetic reminder of the interconnectedness of math and nature.","title":"Conclusion"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1 Measuring Earth's Gravitational Acceleration with a Pendulum Motivation The acceleration due to gravity \\((g)\\) is a fundamental constant that influences motion on Earth. One classic method to determine \\((g)\\) is through the oscillations of a simple pendulum, where the period of the pendulum depends on the gravitational field strength. This experiment offers hands-on practice in both measurement and uncertainty analysis \u2014 core components of experimental physics. Objective Measure the gravitational acceleration \\((g)\\) using a pendulum. Analyze the uncertainties in length and timing. Compare measured \\((g)\\) to the accepted value \\((9.81 , text{m/s}^2)\\) . Materials String of length: 1.00 m Weight: keychain Ruler (\u00b11 cm resolution) Stopwatch (\u00b10.01 s resolution) Support for suspension Procedure Measured pendulum length: \\([ L = 1.00 , \\text{m}, \\quad \\Delta L = \\pm 0.005, \\text{m}]\\) Conducted 10 measurements of the time for 10 full oscillations: \\(( T_{10} )\\) in seconds: 20.02, 19.88, 20.15, 20.00, 20.10, 19.95, 20.05, 20.00, 20.08, 19.90 Tabulated Data Trial Time for 10 Oscillations (s) 1 20.02 2 19.88 3 20.15 4 20.00 5 20.10 6 19.95 7 20.05 8 20.00 9 20.08 10 19.90 Calculations 1. Calculate the period: \\([ T = \\frac{\\\\overline{T}_{10}}{10} = \\frac{20.013}{10} = 2.0013, \\text{s}, \\quad \\Delta T = \\frac{0.0863}{10} = 0.00863, \\text{s}]\\) 2. Determine \\((g)\\) : \\([g = \\frac{4\\pi^2 L}{T^2} = \\frac{4\\\\pi^2 \\cdot 1.00}{(2.0013)^2} \\approx 9.857, \\text{m/s}^2]\\) 3. Propagate uncertainties: \\([\\Delta g = g \\sqrt{ \\left( \\frac{\\\\Delta L}{L} \\right)^2 + \\left( 2 \\cdot \\\\frac{\\Delta T}{T} \\right)^2 }]\\) \\([\\Delta g = 9.857 \\cdot \\sqrt{ \\left( \\\\frac{0.005}{1.00} \\right)^2 + \\left( 2 \\\\cdot \\frac{0.0273}{2.0013} \\right)^2 } \\\\approx 0.273, \\text{m/s}^2]\\) Final Result \\([g = (9.857 \\pm 0.273), \\text{m/s}^2]\\) Python Simulation of Pendulum Motion To better understand the relationship between the pendulum\u2019s period and gravity, we simulate the motion using the formula: \\(\\theta(t) = \\theta_0 \\cos\\left(\\frac{2\\\\pi t}{T}\\right)\\) Where: \\((\\theta_0)\\) is the initial angle (in radians) \\((T = 2\\pi \\sqrt{L / g})\\) is the period Python Code import numpy as np import matplotlib.pyplot as plt # Simulate simple pendulum period based on L and g def pendulum_period(L, g=9.81): return 2 * np.pi * np.sqrt(L / g) # Simulate oscillation and time trace def simulate_pendulum_motion(L, g=9.81, theta0_deg=5, time_max=10, dt=0.01): theta0 = np.radians(theta0_deg) T = pendulum_period(L, g) t = np.arange(0, time_max, dt) theta = theta0 * np.cos(2 * np.pi * t / T) return t, theta, T # Parameters L_sim = 1.0 # length in meters g_sim = 9.81 # gravitational acceleration t_vals, theta_vals, T_theoretical = simulate_pendulum_motion(L_sim, g_sim) # Plot the simulated angular displacement vs time plt.figure(figsize=(10, 4)) plt.plot(t_vals, theta_vals) plt.title(f\"Simulated Pendulum Motion (L = {L_sim} m, g = {g_sim} m/s\u00b2)\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angular Displacement (rad)\") plt.grid(True) plt.tight_layout() plt.show() Analysis 1. Comparison: Measured \\((g)\\) : 9.857 m/s\u00b2 Standard \\((g)\\) : 9.81 m/s\u00b2 Absolute error: 0.047 m/s\u00b2 Relative error: \\(frac{0.047}{9.81} \\times 100\\\\% \\approx 0.48\\\\%\\) 2. Discussion: Effect of \u0394L : The uncertainty in length (\u00b10.005 m) contributed minimally compared to timing uncertainty. Effect of \u0394T : Variability in human reaction time causes larger uncertainty in timing. Measuring 10 oscillations helps reduce this. Limitations : Small angle approximation must hold (<15\u00b0). Air resistance and friction at the pivot are ignored. Stopwatch precision and user reaction time affect reliability. Conclusion Using a basic pendulum and careful timing, we measured the gravitational acceleration as: \\(\\boxed{g = (9.857 \\\\pm 0.273) \\\\, \\text{m/s}^2}\\) This result agrees well with the standard value, with less than 0.5% error. The experiment highlights how even simple tools \u2014 combined with multiple trials and uncertainty analysis \u2014 can yield precise and meaningful scientific results.","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#measuring-earths-gravitational-acceleration-with-a-pendulum","text":"","title":"Measuring Earth's Gravitational Acceleration with a Pendulum"},{"location":"1%20Physics/7%20Measurements/Problem_1/#motivation","text":"The acceleration due to gravity \\((g)\\) is a fundamental constant that influences motion on Earth. One classic method to determine \\((g)\\) is through the oscillations of a simple pendulum, where the period of the pendulum depends on the gravitational field strength. This experiment offers hands-on practice in both measurement and uncertainty analysis \u2014 core components of experimental physics.","title":"Motivation"},{"location":"1%20Physics/7%20Measurements/Problem_1/#objective","text":"Measure the gravitational acceleration \\((g)\\) using a pendulum. Analyze the uncertainties in length and timing. Compare measured \\((g)\\) to the accepted value \\((9.81 , text{m/s}^2)\\) .","title":"Objective"},{"location":"1%20Physics/7%20Measurements/Problem_1/#materials","text":"String of length: 1.00 m Weight: keychain Ruler (\u00b11 cm resolution) Stopwatch (\u00b10.01 s resolution) Support for suspension","title":"Materials"},{"location":"1%20Physics/7%20Measurements/Problem_1/#procedure","text":"Measured pendulum length: \\([ L = 1.00 , \\text{m}, \\quad \\Delta L = \\pm 0.005, \\text{m}]\\) Conducted 10 measurements of the time for 10 full oscillations: \\(( T_{10} )\\) in seconds: 20.02, 19.88, 20.15, 20.00, 20.10, 19.95, 20.05, 20.00, 20.08, 19.90","title":"Procedure"},{"location":"1%20Physics/7%20Measurements/Problem_1/#tabulated-data","text":"Trial Time for 10 Oscillations (s) 1 20.02 2 19.88 3 20.15 4 20.00 5 20.10 6 19.95 7 20.05 8 20.00 9 20.08 10 19.90","title":"Tabulated Data"},{"location":"1%20Physics/7%20Measurements/Problem_1/#calculations","text":"","title":"Calculations"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-calculate-the-period","text":"\\([ T = \\frac{\\\\overline{T}_{10}}{10} = \\frac{20.013}{10} = 2.0013, \\text{s}, \\quad \\Delta T = \\frac{0.0863}{10} = 0.00863, \\text{s}]\\)","title":"1. Calculate the period:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-determine-g","text":"\\([g = \\frac{4\\pi^2 L}{T^2} = \\frac{4\\\\pi^2 \\cdot 1.00}{(2.0013)^2} \\approx 9.857, \\text{m/s}^2]\\)","title":"2. Determine \\((g)\\):"},{"location":"1%20Physics/7%20Measurements/Problem_1/#3-propagate-uncertainties","text":"\\([\\Delta g = g \\sqrt{ \\left( \\frac{\\\\Delta L}{L} \\right)^2 + \\left( 2 \\cdot \\\\frac{\\Delta T}{T} \\right)^2 }]\\) \\([\\Delta g = 9.857 \\cdot \\sqrt{ \\left( \\\\frac{0.005}{1.00} \\right)^2 + \\left( 2 \\\\cdot \\frac{0.0273}{2.0013} \\right)^2 } \\\\approx 0.273, \\text{m/s}^2]\\)","title":"3. Propagate uncertainties:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#final-result","text":"\\([g = (9.857 \\pm 0.273), \\text{m/s}^2]\\)","title":"Final Result"},{"location":"1%20Physics/7%20Measurements/Problem_1/#python-simulation-of-pendulum-motion","text":"To better understand the relationship between the pendulum\u2019s period and gravity, we simulate the motion using the formula: \\(\\theta(t) = \\theta_0 \\cos\\left(\\frac{2\\\\pi t}{T}\\right)\\) Where: \\((\\theta_0)\\) is the initial angle (in radians) \\((T = 2\\pi \\sqrt{L / g})\\) is the period","title":"Python Simulation of Pendulum Motion"},{"location":"1%20Physics/7%20Measurements/Problem_1/#python-code","text":"import numpy as np import matplotlib.pyplot as plt # Simulate simple pendulum period based on L and g def pendulum_period(L, g=9.81): return 2 * np.pi * np.sqrt(L / g) # Simulate oscillation and time trace def simulate_pendulum_motion(L, g=9.81, theta0_deg=5, time_max=10, dt=0.01): theta0 = np.radians(theta0_deg) T = pendulum_period(L, g) t = np.arange(0, time_max, dt) theta = theta0 * np.cos(2 * np.pi * t / T) return t, theta, T # Parameters L_sim = 1.0 # length in meters g_sim = 9.81 # gravitational acceleration t_vals, theta_vals, T_theoretical = simulate_pendulum_motion(L_sim, g_sim) # Plot the simulated angular displacement vs time plt.figure(figsize=(10, 4)) plt.plot(t_vals, theta_vals) plt.title(f\"Simulated Pendulum Motion (L = {L_sim} m, g = {g_sim} m/s\u00b2)\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angular Displacement (rad)\") plt.grid(True) plt.tight_layout() plt.show()","title":"Python Code"},{"location":"1%20Physics/7%20Measurements/Problem_1/#analysis","text":"","title":"Analysis"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-comparison","text":"Measured \\((g)\\) : 9.857 m/s\u00b2 Standard \\((g)\\) : 9.81 m/s\u00b2 Absolute error: 0.047 m/s\u00b2 Relative error: \\(frac{0.047}{9.81} \\times 100\\\\% \\approx 0.48\\\\%\\)","title":"1. Comparison:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-discussion","text":"Effect of \u0394L : The uncertainty in length (\u00b10.005 m) contributed minimally compared to timing uncertainty. Effect of \u0394T : Variability in human reaction time causes larger uncertainty in timing. Measuring 10 oscillations helps reduce this. Limitations : Small angle approximation must hold (<15\u00b0). Air resistance and friction at the pivot are ignored. Stopwatch precision and user reaction time affect reliability.","title":"2. Discussion:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#conclusion","text":"Using a basic pendulum and careful timing, we measured the gravitational acceleration as: \\(\\boxed{g = (9.857 \\\\pm 0.273) \\\\, \\text{m/s}^2}\\) This result agrees well with the standard value, with less than 0.5% error. The experiment highlights how even simple tools \u2014 combined with multiple trials and uncertainty analysis \u2014 can yield precise and meaningful scientific results.","title":"Conclusion"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}